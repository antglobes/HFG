--[[
    Last Edited: 21/03/25
    Author: antglobes
    Purpose: Manage Generator UI
--]]

-- Lib Imports
ag_utils.import_metatable(this, ag_game_objects)
ag_utils.import_metatable(this, ag_maths)
ag_utils.import_metatable(this, ag_npc)
ag_utils.import_metatable(this, ag_position)
ag_utils.import_metatable(this, ag_strings)
ag_utils.import_metatable(this, ag_tables)

gts = get_translation

-- Script Imports
gray = demonized_geometry_ray.geometry_ray

-- Utils
bone_to_part_name = hfg_utils.bone_to_part_name
get_config = hfg_utils.get_config

-- Constants
MAX_FUEL = 60
MAX_POWER_OUTPUT = 5000
SEARCH_RADIUS = 50
PART_FUNC_COND = 0.4
PART_REPAIR_COND = 0.25
UI_GRAY_1 = utils_xml.get_color("ui_gray_1")
RED_CLR    = {255, 255, 19, 18}
ORANGE_CLR = {255, 255, 77, 18}
YELLOW_CLR = {255, 255, 242, 18}
GREEN_CLR  = {255, 64, 253, 40}
LOG_HEADER = "[HFG|Gen UI]"

-- Variables
GUI = nil
local clr_cache = {}
local dbg_pr = nil
local mouse_cache = {}
ini_repair = ini_file_ex("items\\items\\items_repair.ltx")

-- Tables
SWAP_POWER_STATE = {
    on = "off",
    off = "on",
    broken = "broken"
}
CONDITION_CLR = {
    [0]   = RED_CLR,
    [25]  = RED_CLR,
    [50]  = ORANGE_CLR,
    [75]  = YELLOW_CLR,
    [100] = GREEN_CLR,
}
HUDS = {
    show_devices = UIPowerableDevices
}
BTN_TEXT = {
    show_devices = {
        show = "Hide Connected Devices",
        hide = "Show Connected Devices"
    }
}
-- DEBUGGING
function setup_log(level, header, enabled)
    if not dbg_pr then
        dbg_pr = ag_logging.new({
            level=level,
            header=header,
            enabled=enabled
        })
    else
        dbg_pr:SetLevel(level)
        dbg_pr:Enable(enabled)
    end
end

function dbg(level, fmt, ...)
    if not dbg_pr then
        setup_log(get_config("debug_level"), LOG_HEADER, get_config("enable_debug"))    
    
    end
    dbg_pr:Log(level, fmt, ...)
end

function change_alpha(clr, a)
    if not clr and a ~= nil then return end

    if not clr_cache[clr .. "_" .. a] then
        local b = bit.band(clr, 255)
        local g = bit.band(bit.rshift(clr, 8), 255)
        local r = bit.band(bit.rshift(clr, 16), 255)
        clr_cache[clr .. "_" .. a] = GetARGB(a, r, g, b)
    end

    return clr_cache[clr .. "_" .. a]
end

function get_condition_clr(condition, as_table)
    condition = condition * 100
    for _, percent in pairs({0, 25, 50, 75, 100}) do
        if condition <= percent then
            return as_table and CONDITION_CLR[percent] or strformat("%c[%s %s %s %s]", unpack(CONDITION_CLR[percent]))
        end
    end
end

function disp_time(time)
    local days = math.floor(time/86400)
    local hours = math.floor(math.fmod(time, 86400)/3600)
    local minutes = math.floor(math.fmod(time,3600)/60)
    local seconds = math.floor(math.fmod(time,60))
    return days, hours, minutes, seconds
end


function build_gen_info(data)
    local cond = data["condition"]

    local stored_fuel = data["stored_fuel"]
    local fuel_cond = stored_fuel/MAX_FUEL

    local time_til_empty = data["time_til_empty"] 
    local D, h, m, s = disp_time(time_til_empty)
    local hours = h + (D * 24)
    local time_cond = (hours > 24 and 1) or (hours > 18 and 0.75) or (hours > 12 and 0.5) or (hours > 6 and 0.25) or 0

    local power_output = (data["power_state"] ~= "on" and 0) or data["power_output"]
    local power_cond = power_output/MAX_POWER_OUTPUT

    local connected_devices = size_table(data["powerable_devices"]) or 0

    local cond_str   = UI_GRAY_1 .. gts("st_bullet_point") .. " Condition: "         .. strformat("%s", get_condition_clr(cond))       .. strformat("%s%", round_dp(cond*100, 2))
    local fuel_str   = UI_GRAY_1 .. gts("st_bullet_point") .. " Fuel Stored: "       .. strformat("%s", get_condition_clr(fuel_cond))  .. strformat("%sL", round_dp(stored_fuel, 2))
    local time_str   = UI_GRAY_1 .. gts("st_bullet_point") .. " Time Til Empty: "    .. strformat("%s", get_condition_clr(time_cond))  .. strformat("%s days %shrs %sm %ss", D, h, m, s)
    local power_str  = UI_GRAY_1 .. gts("st_bullet_point") .. " Power Output: "      .. strformat("%s", get_condition_clr(power_cond)) .. strformat("%sW", round_dp(power_output, 0))
    local device_str = UI_GRAY_1 .. gts("st_bullet_point") .. " Connected Devices: " .. strformat("%s", get_condition_clr(power_cond)) .. strformat("%s", connected_devices)

    local info_str = strformat("%s\\n%s\\n%s\\n%s\\n%s\\n", cond_str, fuel_str, time_str, power_str, device_str)
    -- pr("info str: %s", info_str)
    return info_str
end

function start_ui(obj_id)
    if not GUI then
        GUI = UIDieselGenerator()
    end

    if GUI and not GUI:IsShown() then
        GUI:Reset(obj_id)
        GUI:ShowDialog(true)
        Register_UI("UIDieselGenerator")
    end
end

class "UIDieselGenerator" (CUIScriptWnd)
function UIDieselGenerator:__init() super()
    self:InitControls()
    self:InitCallbacks()
end

function UIDieselGenerator:InitControls()
    self:SetWndRect(Frect():set(0,0,1024,768))
    self:SetAutoDelete(true)

    self.xml = CScriptXmlInit()
    self.xml:ParseFile("ui_hfg_diesel_generator.xml")

    self.dialog            = self.xml:InitFrame("dialog", self)
    self.bg                = self.xml:InitStatic("background", self.dialog)
    self.frame             = self.xml:InitFrame("frame", self.dialog)
    self.title             = self.xml:InitTextWnd("title", self.frame)
    self.info_box          = self.xml:InitTextWnd("info_box", self.frame)
    self.add_fuel_btn      = self.xml:Init3tButton("add_fuel", self.frame)
    self.take_fuel_btn     = self.xml:Init3tButton("take_fuel", self.frame)
    self.toggle_power_btn  = self.xml:Init3tButton("toggle_power", self.frame)
    self.show_devices_btn  = self.xml:Init3tButton("show_devices", self.frame)
    self.show_repair_btn   = self.xml:Init3tButton("show_repair", self.frame)

    self:Register(self.add_fuel_btn, "add_fuel_btn")
    self:Register(self.take_fuel_btn, "take_fuel_btn")
    self:Register(self.toggle_power_btn, "toggle_power_btn")
    self:Register(self.show_devices_btn, "show_devices_btn")
    self:Register(self.show_repair_btn, "show_repair_btn")

    local bg_clr = self.bg:GetTextureColor()
    self.bg:SetTextureColor(change_alpha(bg_clr, 100))
    self.title:SetText("Diesel Generator Info:")

    -- Repair UI
    self.repair_frame      = self.xml:InitFrame("frame", self.dialog)
    self.repair_title      = self.xml:InitTextWnd("repair_title", self.repair_frame)
    self.repair_list       = self.xml:InitListBox("repair_list", self.repair_frame)
    self.repair_btn        = self.xml:Init3tButton("repair_btn", self.repair_frame)
    self.replace_btn       = self.xml:Init3tButton("replace_btn", self.repair_frame)
    self.back_btn          = self.xml:Init3tButton("back_btn", self.repair_frame)

    self:Register(self.repair_list, "repair_list")
    self:Register(self.repair_btn, "repair_btn")
    self:Register(self.replace_btn, "replace_btn")
    self:Register(self.back_btn, "back_btn")

    self.repair_title:SetText("Part Info")
    self.repair_frame:Show(false)
end

function UIDieselGenerator:InitCallbacks()
    self:AddCallback("add_fuel_btn", ui_events.BUTTON_CLICKED, self.AddFuel, self)
    self:AddCallback("take_fuel_btn", ui_events.BUTTON_CLICKED, self.TakeFuel, self)
    self:AddCallback("toggle_power_btn", ui_events.BUTTON_CLICKED, self.TogglePower, self)
    self:AddCallback("show_devices_btn", ui_events.BUTTON_CLICKED, self.ShowDevices, self)
    self:AddCallback("show_repair_btn", ui_events.BUTTON_CLICKED, self.ShowRepair, self)
    -- Repair UI
    self:AddCallback("repair_list", ui_events.LIST_ITEM_CLICKED, self.RepairList, self)
    self:AddCallback("repair_btn", ui_events.BUTTON_CLICKED, self.RepairBtn, self)
    self:AddCallback("replace_btn", ui_events.BUTTON_CLICKED, self.ReplaceBtn, self)
    self:AddCallback("back_btn", ui_events.BUTTON_CLICKED, self.BackBtn, self)
end

function UIDieselGenerator:LoadPartInfo()
    dbg("debug", "on load part info")
    self.repair_list:RemoveAll()
    local parts = hf_obj_manager.get_data(self.gen_id).parts
    --dbg("dev", "Receving parts: %s", parts)
    local idx = 0
    for part_name, part_info in pairs(parts) do
        local part_info = self:GetPartInfo(part_info)
        local item = repair_item(idx, part_info) 
        self.repair_list:AddExistingItem(item)
        idx = idx + 1
    end
end

function UIDieselGenerator:GetPartInfo(part_info)
    part_info.repairable = part_info.condition >= PART_REPAIR_COND
    part_info.functional = part_info.condition >= PART_FUNC_COND
    return part_info
end


function UIDieselGenerator:Reset(obj_id)
    dbg("dev", "gen id: %s", obj_id)
    self.gen_id = obj_id
    self.screen_id = 1
    self.screens = {
        [1] = "info",
        [2] = "repair"
    }
    self.show_devices = false
    self.show_repair = false
    self.repair_list:RemoveAll()
    self:SetPowerStateText()
end

function UIDieselGenerator:Close()
    dbg("debug", "on close")
    if (self:IsShown()) then
		self:HideDialog()
	end
    self.init = false
    Unregister_UI("UIDieselGenerator")
end

function UIDieselGenerator:Update()
    CUIScriptWnd.Update(self)

    local data = hf_obj_manager.get_data(self.gen_id)
    if not data then return end
    local active_screen = self.screens[self.screen_id]
    local tg = time_global()
    --pr("Showing screen: %s", active_screen)
    if active_screen == "info" then
        if not self.frame:IsShown() then
            self.frame:Show(true)
        end
        self.repair_frame:Show(false)

        local gen_info = build_gen_info(data)
        self.info_box:SetText(gen_info)

    elseif active_screen == "repair" then
        if self.frame:IsShown() then
            self.frame:Show(false)
        end
        self.repair_frame:Show(true)

        self:UpdatePartInfo()
    end 
    
    if self.show_devices then
        update_marker_hud(self.gen_id)
    end
end

function UIDieselGenerator:UpdatePartInfo()
    if self.repair_list:GetSize() == 0 then return end
    -- pr("updating part info")
    -- pr("repair list size: %s", self.repair_list:GetSize())
    local parts = hf_obj_manager.get_data(self.gen_id).parts
    for i=0, self.repair_list:GetSize() - 1 do
        local itm = self.repair_list:GetItemByIndex(i)
        local part_name = itm["part_info"].name
        local new_part_info = parts[part_name]
        local part_info = self:GetPartInfo(new_part_info)
        if itm["part_info"].condition ~= part_info.condition then
            itm.condition:SetText(strformat("Condition: %s%", round_idp(part_info["condition"] * 100, 2)))
        end
        if itm["part_info"].repairable ~= part_info.repairable then
           itm.repairable:SetText(strformat("Repairable: %s", part_info["repairable"] and "Yes" or "No")) 
        end
        if itm["part_info"].functional ~= part_info.functional then
            itm.functional:SetText(strformat("Functional: %s", part_info["functional"] and "Yes" or "No"))
        end
    end
end

function UIDieselGenerator:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		
			if dik == DIK_keys.DIK_ESCAPE then
                dbg("info", "esc key pressed")
				self:Close()
			end

		end
	end

	return res
end

function UIDieselGenerator:Pickup()

end

function UIDieselGenerator:SetPowerStateText()
    local data = hf_obj_manager.get_data(self.gen_id)
    local power_state = data["power_state"]
    local new_power_state = SWAP_POWER_STATE[power_state]
    self.toggle_power_btn:TextControl():SetText(strformat("Toggle Power: %s", capitalise(new_power_state)))
end

function UIDieselGenerator:TogglePower()
    if bind_disel_generator.toggle_power(self.gen_id) then
        self:SetPowerStateText()
    end
end

function UIDieselGenerator:AddFuel()
    local found_jerrycans = find_inv_item("jerrycan")
    for idx, obj in pairs(found_jerrycans) do
        local sect = obj:section()
        if sect ~= "hfg_jerrycan_diesel_empty" then
            dbg("debug", "adding fuel")
            bind_generator_item.add_fuel(obj, self.gen_id)
        end
    end
end

function UIDieselGenerator:TakeFuel()
    local found_jerrycans = find_inv_item("jerrycan")
    for idx, obj in pairs(found_jerrycans) do
        dbg("debug", "Taking fuel")
        bind_generator_item.take_fuel(obj, self.gen_id)
    end
end

function UIDieselGenerator:ToggleMarkerHud(marker_type)
    if not contains(marker_huds, self.gen_id) then
        init_marker_hud(self.gen_id, UIPowerableDevices)
    end
    dbg("dev", "marker type: %s", marker_type)
    if not self[marker_type] then
        show_marker_hud(self.gen_id)
        self[marker_type] = true
        self[marker_type .. "_btn"]:TextControl():SetText(BTN_TEXT[marker_type]["show"])
    else
        hide_marker_hud(self.gen_id, true)
        self[marker_type] = false
        self[marker_type .. "_btn"]:TextControl():SetText(BTN_TEXT[marker_type]["hide"])
    end
end

function UIDieselGenerator:ShowDevices()
    dbg("debug", "on show devices")
    local data = hf_obj_manager.get_data(self.gen_id)
    if size_table(data["powerable_devices"]) == 0 then return end
    dbg("dev", "show devices hud?: %s", self.show_devices)
    self:ToggleMarkerHud("show_devices")
end

function UIDieselGenerator:ShowRepair()
    self.screen_id = 2
    self:LoadPartInfo()
end

function UIDieselGenerator:BackBtn()
    self.screen_id = 1
end

function UIDieselGenerator:RepairBtn()
    dbg("debug", "on repair")
    local item = self.repair_list:GetSelectedItem()
    if not item then return end
    local part_info = item.part_info
    local part_name = part_info["name"]
    local part_cond = part_info["condition"]
    local item_name = gts(ini_sys:r_string_ex(part_name, "inv_name"))
    dbg("info", "attempting to repair %s", item_name)

     if part_cond >= 0.95  then
        actor_menu.set_msg(1, gts("st_part_perfect", item_name), 3)
        dbg("info", "Part perfect")
        return
    end

    if not part_info["repairable"] then
        actor_menu.set_msg(1, gts("st_part_unrepairable", item_name), 3)
        return
    end

    local found_repair_kits = {}
    local found_support_items = {}
    local repair_type = ini_sys:r_string_ex(item_name, "repair_type")
    dbg("dev", "finding repair kits")
    itr_inv(db.actor, function(_, obj)
        local sect = obj:section()
        if ini_repair:section_exist(sect) and contains(parse_list(ini_repair, sect, "repair_only"), repair_type) then
            found_repair_kits[#found_repair_kits + 1].obj = obj
            found_repair_kits[#found_repair_kits + 1].sect = sect
            found_repair_kits[#found_repair_kits + 1].uses = obj:get_remaining_uses()
            found_repair_kits[#found_repair_kits + 1].add = ini_sys:r_float_ex(sect, "repair_add_condition") or 0
            found_repair_kits[#found_repair_kits + 1].bonus = ini_sys:r_float_ex(sect, "repair_part_bonus") or 0
            found_support_items = parse_list(ini_repair, sect, "repair_parts_sections")
        end
    end)

    if is_empty(found_repair_kits) then
        actor_menu.set_msg(1, gts("st_repair_kit_missing", item_name), 3)    
        return
    end

    dbg("dev", "finding support items")
    itr_inv(db.actor, function(_, obj)
        local sect = obj:section()
        if contains(found_support_items, sect) then
            found_support_items[#found_support_items + 1].obj = obj
            found_support_items[#found_support_items + 1].sect = sect
            found_support_items[#found_support_items + 1].bonus = ini_sys:r_string_ex(obj:section(), "repair_part_bonus") or 0
        end
    end)

    local best_support_item = {}
    if is_not_empty(found_support_items) then
        dbg("dev", "getting support items with highest bonus")
        local highest_bonus
        for idx, support_item in pairs(found_support_items) do
            local bonus = support_item.bonus
            if not highest_bonus or bonus > highest_bonus then
                best_support_item = support_item
                highest_bonus = bonus
            end
        end
        dbg("dev", "found %s with bonus %s", best_support_item.sect, best_support_item.bonus)
    end

    dbg("dev", "finding repair kit with lowest uses")
    local worst_repair_kit = {}
    if #found_repair_kits == 1 then
        worst_repair_kit = found_repair_kits[#found_repair_kits]
    else
        local lowest_uses
        for idx, repair_kit in pairs(found_repair_kits) do
            local uses = repair_kit.uses or 0
            if not lowest_uses or uses < lowest_uses then
                worst_repair_kit = repair_kit
                lowest_uses = uses
            end
        end
    end
    
    if not worst_repair_kit then
        actor_menu.set_msg(1, gts("st_repair_kit_missing", item_name), 3)    
        return
    end
    dbg("dev", "found repair kit with uses: %s", worst_repair_kit.sect )
    dbg("dev", "part_cond:%s", part_cond)
    local support_item_cond = 0
    if best_support_item then 
        support_item_cond = best_support_item.obj:condition() or best_support_item.bonus
    else
        support_item_cond = worst_repair_kit.bonus
    end
    dbg("dev", "support item cond: %s", support_item_cond)
    local add_cond =  worst_repair_kit.add 
    local total_cond = part_cond + support_item_cond + add_cond
    local item_cond = clamp(total_cond, part_cond, 1)
    dbg("dev", "add cond: %s, total cond: %s. item_cond:%s", add_cond, total_cond, item_cond)

    dbg("dev", "updating hf data")
    local data = hf_obj_manager.get_data(self.gen_id)
    data["parts"][part_name].condition = item_cond
    hf_obj_manager.update_data(self.gen_id, data)

    if best_support_item then
        utils_item.discharge(best_support_item.obj)
        dbg("dev", "discharging use from: %s", best_support_item.sect)
    end

    if IsItem("multiuse", nil, worst_repair_kit.obj) then
		utils_item.discharge( worst_repair_kit.obj) 
        dbg("dev", "discharging use from: %s", worst_repair_kit.sect)
	else
		utils_item.degrade( worst_repair_kit.obj, 0.2)
        dbg("dev", "degrading %s by 0.2", worst_repair_kit.sect)
	end
	
    actor_effects.play_item_fx( worst_repair_kit.sect .. "_dummy")
    game_statistics.increment_statistic("self_repairs")
    utils_obj.play_sound("interface\\inv_repair_kit_use_fast")

    self:LoadPartInfo()
end

function UIDieselGenerator:ReplaceBtn()
    dbg("debug", "on replace")
    local item = self.repair_list:GetSelectedItem()
    if not item then return end
    local part_info = item["part_info"]
    local part_name = part_info["name"]
    local part_cond = part_info["condition"]
    local item_name = gts(ini_sys:r_string_ex(part_name, "inv_name"))

    if part_cond >= 0.95  then
        actor_menu.set_msg(1, gts("st_part_perfect", item_name), 3)
        return
    end

    local replacements = {}
    itr_inv(db.actor, function(_, obj)
        local sect = obj:section()
        if sect == item_name then
            replacements[obj:id()] = obj:condition() or 1
        end
    end)
    
    if is_empty(replacements) then
        actor_menu.set_msg(1, gts("st_replacement_missing", item_name), 3)
        return 
    end

    local replace_id
    local highest_cond
    for id, condition in pairs(replacements) do
        if not highest_cond or highest_cond < condition then
            highest_cond = condition
            replace_id = id
        end
    end

    if highest_cond <= part_cond then
        actor_menu.set_msg(1, gts("st_highest_part", item_name), 3)
        return
    end

    alife_release(alife_object(replace_id))
    local data = hf_obj_manager.get_data(self.gen_id)
    data["parts"][part_name].condition = highest_cond
    dbg("info", "replacing %s condition: %s to be %s", part_name, part_cond, highest_cond)

    hf_obj_manager.update_data(self.gen_id, data)
    utils_obj.play_sound("interface\\inv_disassemble_metal_fast_1")

    self:LoadPartInfo()
end
-- ---------------------------------------------------------------------------

class "repair_item" (CUIListBoxItem)
function repair_item:__init(idx, part_info) super(idx, part_info)
    dbg("debug", "init repair item")
    self.idx = idx
    self.part_info = part_info

    self:SetWndSize(vector2():set(200, 70))
    local width = self:GetWidth()
    local height = self:GetHeight()
    self:GetTextItem():SetText("")

    local icon_w = 50
    local icon_h = icon_w
    self.icon = self:AddIconField(1)
    --pr("ui_" .. part_info["part_name"])
    self.icon:InitTexture("ui_" .. part_info["name"])
    self.icon:SetStretchTexture(true)
    self.icon:SetWndPos(vector2():set(width / 2 - icon_w / 2, (height / 2 - icon_h / 2) + 10))
    self.icon:SetWndSize(vector2():set(icon_w, icon_h))
    local icon_clr = self.icon:GetTextureColor()
    self.icon:SetTextureColor(change_alpha(icon_clr, 200))

    self.part_name = self:AddTextField(gts(ini_sys:r_string_ex(part_info["name"], "inv_name")), 1)
    self.part_name:SetTextAlignment(CGameFont.alCenter)
    local part_name_len = #part_info["name"]
    local part_w = part_name_len % 2 == 0 and part_name_len or part_name_len - 1
    local part_h = 10
    self.part_name:SetWndPos(vector2():set(0, 10))
    self.part_name:SetWndSize(vector2():set(width, part_h))

    self.condition = self:AddTextField(strformat("Condition: %s%", round_idp(part_info["condition"] * 100, 2)), 1)
    self.condition:SetTextAlignment(CGameFont.alleft)
    self.condition:SetWndPos(vector2():set(0, 25))
    self.condition:SetWndSize(vector2():set(width, part_h))

    local repairable = part_info["repairable"]
    self.repairable = self:AddTextField(strformat("Repairable: %s", repairable and "Yes" or "No"), 1)
    self.repairable:SetTextAlignment(CGameFont.alLeft)
    self.repairable:SetWndPos(vector2():set(0, 40))
    self.repairable:SetWndSize(vector2():set(width, part_h))

    local functional = part_info["functional"]
    self.functional = self:AddTextField(strformat("Functional: %s", functional and "Yes" or "No"), 1)
    self.functional:SetTextAlignment(CGameFont.alLeft)
    self.functional:SetWndPos(vector2():set(0, 55))
    self.functional:SetWndSize(vector2():set(width, part_h))
end

function repair_item:__finalize()
end

-- ============================================================================

-- Marker Huds
marker_huds = {}
function init_marker_hud(id, hud)
    if not contains(marker_huds, id, true) then
        marker_huds[id] = hud(id)
    end
end

function show_marker_hud(id)
    if not contains(marker_huds, id, true) then return end
    get_hud():AddDialogToRender(marker_huds[id])
end

function hide_marker_hud(gen_id, remove)
    if not contains(marker_huds, gen_id, true) then return end
    if marker_huds[gen_id] then
        get_hud():RemoveDialogToRender(marker_huds[gen_id])
        if remove then
            marker_huds[gen_id] = nil
        end
    end
end

function remove_all_marker_huds()
    for id, _ in pairs(marker_huds) do
        hide_marker_hud(id, true)
    end
end

function hide_all_marker_huds()
    if is_empty(marker_huds) then return end
    for id, _ in pairs(marker_huds) do
        hide_marker_hud(id)
    end
end

function show_all_marker_huds()
    if is_empty(marker_huds) then return end
    for id, _ in pairs(marker_huds) do
        show_marker_hud(id)
    end
end

local ui_shown = false
function on_ui(name)
    if not contains({"UIInventory", "UIDialog", "UICraft", "UICook", "UIWorkshop", "UITrade"}, name) then return end
    if not ui_shown then
        hide_all_marker_huds()
        ui_shown = true
    else
        show_all_marker_huds()
        ui_shown = false
    end
end

function update_marker_hud(gen_id)
    if not contains(marker_huds, gen_id, true) then return end
    if marker_huds[gen_id] then
        marker_huds[gen_id]:Update(true)
    end
end

class "UIPowerableDevices" (CUIScriptWnd)
function UIPowerableDevices:__init(gen_id) super(gen_id)
    self.xml = CScriptXmlInit()
    self.xml:ParseFile("ui_marker_hud.xml")
    self:AllowMovement(true)
    self.ratio = (1024/768)/(device().width/device().height)

    self.markers = {}
    self.devices = {}
    self.gen_id = gen_id
    self.tmr = 0
    self.delay = 1000
    self.show_device = false
end

function UIPowerableDevices:__finalize()
    for id, _ in pairs(self.markers) do
        self.markers[id]:Show(false)
        self.markers[id] = nil
    end
end

function UIPowerableDevices:Update()
    CUIScriptWnd.Update(self)
    self.powerable_devices = hf_obj_manager.get_data(self.gen_id).powerable_devices

    self:UpdateObjects()
    self:UpdateMarkers()
end

function UIPowerableDevices:UpdateObjects()
    local tg = time_global()
    if self.tmr > tg then
        return
    end
    self.tmr = tg + self.delay

    self.show_device = main_hud_shown()

    for id, sect in pairs(self.powerable_devices) do
        local obj = get_unknown_object({id=id}, "game")
        if obj then
            if self:ValidateDevice(obj) then
                if not contains(self.devices, obj:id(), true) then
                    self.devices[id] = obj:section()
                end
            else
                if contains(self.devices, obj:id(), true) then
                    self.devices[id] = nil
                end
                if contains(self.markers, obj:id(), true) then
                    self.markers[obj:id()]:Show(false)
                    self.markers[id] = nil
                end
            end
        end
    end
end


function UIPowerableDevices:UpdateMarkers()
    -- Init Non existing markers
    for id, sect in pairs(self.devices) do
        local obj = get_unknown_object({id=id}, "game")
        if obj and not contains(self.markers, obj:id(), true) then
            self.markers[obj:id()] = self.xml:InitStatic(self:GetDeviceIcon(sect), self)
            self:ApplyScreenRatio(self.markers[obj:id()])
            self.markers[obj:id()]:SetStretchTexture(true)
            self.markers[obj:id()]:Show(false)
        end
    end

    -- update markers
    for id, _ in pairs(self.markers) do
        local obj = get_unknown_object({id=id}, "game")
        if obj then
            local pos = vector():set(obj:position()):add(vector():set(0, 0, 0))
            local vec = game.world2ui(pos, false, false)
            local old_vec = self.markers[id]:GetWndPos()
            vec = lerp_vec_2d(old_vec, vec, device().f_time_delta * 10)
            if self:ScreenPosValid(vec) then
                self.markers[id]:SetWndPos(vec)
                self.markers[id]:Show(true)
            else
                self.markers[id]:Show(false)
            end
        end
    end
end

function UIPowerableDevices:ValidateDevice(obj)
    
    if not obj then
        return false
    end

    if not self.show_device then
        return false
    end
    

    local device_data = hf_obj_manager.get_data(obj:id())
    local genny_data = hf_obj_manager.get_data(self.gen_id)
    local actor_pos = db.actor:position()

    if genny_data["power_state"] == "broken" then
        return false
    end

    if device_data["condition"] <= 0 then
        return false
    end

    local found_gens = find_obj("placeable_disel_generator", actor_pos, SEARCH_RADIUS)
    local found_gen = is_not_empty(found_gens) and get_nearest(found_gens) or false

    if not found_gen then
        return false
    end

    if found_gen:id() ~= self.gen_id then
        return false
    end
    

    local dist_to_gen = distance_between(db.actor, found_gen)
    local gen_radius = (SEARCH_RADIUS / math.pi * 2)
    if dist_to_gen >= gen_radius then
        dbg("error", "dist to gen: %s, gen radius: %s", dist_to_gen, gen_radius)
        return false
    end

    local ray = gray({
        ray_range = distance_between(db.actor, obj),
        flags =  2 + 8,
    })
    local y_boost = 1.6
    if IsMoveState("mcCrouch") then
        y_boost = 1
        if IsMoveState("mcAccel") then
            y_boost = 0.3
        end
    end
    local raised_actor_pos = vector():set(actor_pos.x, actor_pos.y + y_boost, actor_pos.z)
    local obj_pos = obj:position()
    local dir = get_direction(actor_pos, obj_pos)
    local result = ray:get(raised_actor_pos, dir)
    if result.result.material_name then
        dbg("error", "%s obstructing view", result.result.material_name)
        return false
    end
   
    
    return true
end

-- light, lamp, torch, tv
function UIPowerableDevices:GetDeviceIcon(sect)
    local icon_base = "default"
    local item_sect = ini_sys:r_string_ex(sect, "item_section")
    for _, base in pairs({"tv", "lamp", "torch", "light"}) do
        if string.find(item_sect, base) then
            icon_base = base
            break
        end
    end
    if icon_base == "default" then
        local placeable_type = ini_sys:r_string_ex(item_sect, "placeable_type")
        for _, base in pairs({"tv", "lamp", "torch", "light"}) do
            if string.find(placeable_type, base) then
                icon_base = base
                break
            end
        end
    end
    return "marker_"..icon_base
end

---@author: GhenTuong
---@addon:Detection Support
function UIPowerableDevices:ScreenPosValid(vec)
	return (vec.x ~= -9999) and (vec.y ~= 0) and (vec.x <= 1024) and (vec.y <= 768)
end

---@author: GhenTuong
---@addon:Detection Support
function UIPowerableDevices:ApplyScreenRatio(ele)
	if (ele) then
		ele:SetWndSize(vector2():set(ele:GetWidth() * (self.ratio or 1),ele:GetHeight()))
	end
end

function on_option_change(options)
    setup_log(options["debug_level"], LOG_HEADER, options["enable_debug"])
    dbg("debug", "Received options")
    SEARCH_RADIUS = options["search_radius"]
    MAX_FUEL = options["max_fuel"]
    MAX_POWER_OUTPUT = options["max_power_output"]
    BROKEN_COND = options["broken_cond"]
end

function cache_mouse(x, y, disabled, flags)
    mouse_cache = {
        x = x,
        y = y,
        disabled = disabled,
        override = flags.ret_value
    }
end

function on_game_start()
	RegisterScriptCallback("GUI_on_show",on_ui)
	RegisterScriptCallback("GUI_on_hide",on_ui)
    RegisterScriptCallback("actor_on_net_destroy", remove_all_marker_huds)
    RegisterScriptCallback("hfg_on_option_change", on_option_change)
    RegisterScriptCallback("on_before_mouse_move", cache_mouse)
end
