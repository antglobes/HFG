--[[
    Last Edited: 03/08/25
    Author: antglobes
    Purpose: Utiliy Functions (Commonly used functions in codebase)
--]]

-- Lib Imports
ag_utils.import_metatable(this, ag_game_objects)
ag_utils.import_metatable(this, ag_maths)
ag_utils.import_metatable(this, ag_npc)
ag_utils.import_metatable(this, ag_position)
ag_utils.import_metatable(this, ag_strings)
ag_utils.import_metatable(this, ag_tables)
ag_utils.import_metatable(this, ag_configs)

gts = get_translation

-- Script Imports
throttle = ag_utils.throttle

-- Constants
LOG_HEADER = "[HFG|Utils]"
PART_FUNC_COND = 0.4
PLACEABLE_DISEL_GEN = "placeable_disel_generator"
PLACEABLE_SOLAR_PANELS = "placeable_solar_panel"
PLACEABLE_INVERTER = "placable_inverter"
DISEL_GEN_ITEM = "disel_generator_item"
SOLAR_PANEL_ITEM = "hfg_solar_panel"

-- MCM Variables
SEARCH_RADIUS = 50
BROKEN_COND = 0.1

-- Globals
ini_key_to_dik = ini_file_ex("plugins\\key_to_DIK.ltx")

-- Locals
local dbg_pr = nil

-- Tables
ITEM_POWER_SOURCES = {DISEL_GEN_ITEM, SOLAR_PANEL_ITEM}
FUEL_SECTIONS = {"batteries_dead"}
FUELED_POWER_SOURCES = {PLACEABLE_DISEL_GEN}
SWAP_POWER_STATE = {
    on = "off",
    off = "on",
    broken = "broken"
}
GENERATOR_BONE_NAMES = {
    "link", "body", "but_belt", "l_rotor",
    "r_rotor", "tank", "top_belt", "exhaust",
    "battery", "wires", "turbine", "engine",
    "pipes", "fan", "frame-a", "frame-b"
}
part_damage_multi = {
    generator = {
        frame = 1,
        turbine = 1,
        engine = 1,
        pipes = 2,
        fan = 2,
        l_rotor = 2,
        r_rotor = 2,
        battery = 2,
        band = 3,
        exhaust = 3,
        tank = 5,
        wires = 5,
    }
}

-- DEBUGGING
function setup_log(level, header, enabled)
    if not dbg_pr then
        dbg_pr = ag_logging.new({
            level=level,
            header=header,
            enabled=enabled
        })
    else
        dbg_pr:SetLevel(level)
        dbg_pr:Enable(enabled)
    end
end

function dbg(level, fmt, ...)
    if not dbg_pr then
        setup_log(get_config("debug_level"), LOG_HEADER, get_config("enable_debug"))    
    end
    dbg_pr:Log(level, fmt, ...)
end

function get_hf_item_name(obj_sect, as_str_id)
    local item_sect = ini_sys:r_string_ex(obj_sect, "item_section") or obj_sect
    local name = ini_sys:r_string_ex(item_sect, "inv_name")
    return as_str_id and name or gts(name)
end

function bone_to_part_name(bone_name, kind)
    local part_name = ""
    if kind == "generator" then
        part_name = "hfg_prt_"
        if contains({"link", "body", "frame-a", "frame-b"}, bone_name) then
            part_name = part_name .. "frame"
        elseif contains({"turbine", "engine", "wires", "battery", "fan", "exhaust", "pipes", "l_rotor", "r_rotor", "tank"}, bone_name)  then
            part_name = part_name .. bone_name
        elseif contains({"but_belt", "top_belt"}, bone_name) then
            part_name = part_name .. "band"
        end
    elseif kind == "solar_panel" then
        part_name = "hfg_prt_sp_"
        if contains({"bottom_frame", "top_frame"}, bone_name) then
            part_name = part_name .. "frame"
        elseif contains({"left_leg", "middle_leg", "right_leg"}, bone_name) then
            part_name = part_name .. "leg"
        elseif contains({"top_panel", "bottom_panel"}, bone_name) then
            part_name = part_name .. "panel"
        end
    end
    return part_name
end

function get_parts_tbl(sect)
    local parts = itms_manager.ini_parts:r_string_ex("nor_parts_list", sect)
    local parts_tbl = parts and str_explode(parts, ",") or {}
    return parts_tbl
end

function valid_screen_pos(pos)
	return (pos.x ~= -9999) and (pos.y ~= 0) and (pos.x <= 1024) and (pos.y <= 768)
end

function is_object_visible(id)
    local visible = false
    local obj = get_unknown_object({id=id}, "game")
    if obj then
        dbg("info", "object found")
        local max_dist = ui_options.get("video/advanced/optimize_dynamic_geom") * 100
        local dist_to_actor = distance_between(db.actor, obj)

        if dist_to_actor < max_dist then
            dbg("info", "object within distance")
            local pos = vector():set(obj:position()):add(vector():set(0, 0, 0))
            local vec = game.world2ui(pos, false, false)

            if valid_screen_pos(vec) then
                dbg("info", "valid screen pos")
                visible = volumetric_check(obj, math.sqrt(dist_to_actor))
                dbg("info", "checked if behind wall")
            else
                dbg("dev", "invalid screen pos")
            end
        else
            dbg("error", "out of distance")
        end
    else
        dbg("error", "obj not found")
    end
    dbg("dev", "Is %s visible: %s?", id, visible)
    return visible
end

function get_bone_pos(obj, bone_name)    
    --  local bid = obj:get_bone_id(bone_name)
    --  local bpos = obj:bone_position(bid)
    --  return bpos
    return utils_obj.safe_bone_pos(obj, bone_name)
end

function within_range(pos_a, pos_b, radius)
    return pos_a:distance_to(pos_b) <= radius
end


-- HFG Light furniture
function get_solar_panels(pos)
    local found_solar_panels = {}
    local function search(obj)
        local sect = obj:section()
        if sect == PLACEABLE_SOLAR_PANELS then
            found_solar_panels[#found_solar_panels + 1] = obj
        end
    end
    level.iterate_nearest(pos, SEARCH_RADIUS, search)
    return found_solar_panels
end

function sort_obj_by_closest_pos(t, a, b, pos)
    local a_dist = t[a]:position():distance_to(pos)
    local b_dist = t[b]:position():distance_to(pos)
    return a_dist < b_dist
end

function cond_to_state(cond)
    return (cond <= 10 and "broken")
        or (cond <= 35 and "low")
        or (cond <= 80 and "med")
        or "high"
end

function bones_by_distance(obj, pos)
    local obj_bones = obj:list_bones()
    local bone_distances = {}
    for idx, bone_name in pairs(obj_bones) do
        local bone_pos = get_bone_pos(obj, bone_name)
        local dist = bone_pos:distance_to(pos)
        bone_distances[idx] = dist
    end

    local closest_bones = {}    
    for idx, dist in spairs(bone_distances, function(t, a, b) return t[a] > t[b] end) do
        closest_bones[idx] = {}
        closest_bones[idx].dist = dist
        closest_bones[idx].bone_name = obj_bones[idx]
    end
    return closest_bones
end

function dik_to_str(dik, sentence_case)
    if not is_number(dik) then return end
    local keyname = dik_to_keyname(dik)
    if not ini_key_to_dik:line_exist("keys", keyname) then return end
    local dik_str = ini_key_to_dik:r_string_ex("keys", keyname, "none")
    local pattern = dik_str:find("mouse") and "_" or "DIK_"
    local replacement = dik_str:find("mouse") and " " or ""
    dik_str = replace(dik_str, pattern, replacement)
    return sentence_case and capitalise(lowercase(dik_str)) or lowercase(dik_str)
end

-- MCM
function get_config(key)
    return hfg_mcm.get_config(key)
end

function is_key_held(key, duration)
    return ui_mcm.key_hold("hfg", key, duration)
end

function simple_press(key, func)
    ui_mcm.simple_press("hfg", key, func)
end

function double_tap(key)
    return ui_mcm.double_tap("hfg", key)
end

function on_option_change(options)
    setup_log(options["debug_level"], LOG_HEADER, options["enable_debug"])
    dbg("debug", "Received options")
    SEARCH_RADIUS = options["power_source_search_radius"]
    BROKEN_COND = options["power_source_broken_cond"]
end

function on_game_start()
    RegisterScriptCallback("hfg_on_option_change", on_option_change)
    -- RegisterScriptCallback("hf_on_furniture_place", on_place_power_object)
end

--[[
function update_power_output(pd_id, ps_id)
    local is_on = hf_obj_manager.get_data(pd_id).is_on
    local ps_data = hf_obj_manager.get_data(ps_id)
    local curr_power_output = ps_data["power_output"]
    local watts_needed = ps_data["consumers"][pd_id].watts_needed
    local new_power_output = is_on and curr_power_output - watts_needed or curr_power_output + watts_needed
    dbg("dev", "changing power output, from: %s to %s", curr_power_output, new_power_output)
    ps_data["power_output"] = new_power_output
    hf_obj_manager.update_data(ps_id, ps_data)
end

if  and  then
                    dbg("dev", "init powerable device")
                    local wrapper = bind_hf_base.get_wrapper(found_ps_id)
                    if wrapper then
                        ps_data["consumers"][obj_id] = wrapper:InitPDInfo(se_obj)
                        hf_obj_manager.update_data(found_ps_id, ps_data)

                        local pd_wrapper = bind_hf_base.get_wrapper(obj_id)
                        if pd_wrapper then
                            dbg("dev", "init %s powered status", obj_id)
                            pd_wrapper.power_source_id=found_ps_id
                        end

                        local msg = gts("st_connect_device", light_name, gen_name)
                        actor_menu.set_msg(1, msg, 3)
                        return
                    end
                end
]]

-- Callbacks

--[[
function on_place_power_object(obj_id)
    local se_obj = alife_object(obj_id)
    local sect = se_obj:section_name()
    if not se_obj  then return end
    if is_power_object(sect) then return end

    local pos = se_obj.position or db.actor:position()
    dbg("info", "on place power object: %s", sect)
    CreateTimeEvent("on_place_power_object"..se_obj.id, "init_po"..se_obj.id, 0.4, function()        
        local pd_wrapper = bind_hf_base.get_wrapper(se_obj.id)
        if not pd_wrapper then return false end
            if pd_wrapper.init_pd then return true end
            -- Connect Powerable device to nearest power source
            local power_sources = find_power_sources(pos)
            if is_not_empty(power_sources) then
                for _, obj in spairs(power_sources, function(t, a, b) return sort_obj_by_closest_pos(t, a, b, pos) end) do
                    local power_source = obj
                    local ps_id = power_source:id()
                    local ps_sect = power_source:section()
                    pd_wrapper.power_source_id=ps_id

                    local ps_data = hf_obj_manager.get_data(ps_id)
                    local ps_wrapper = bind_hf_base.get_wrapper(ps_id)
                    if 
                        ps_wrapper 
                        and ps_data
                        and not contains(ps_data["consumers"], obj_id, true)
                        and contains(ps_data, "power_output", true)
                    then
                        local pd_name = get_hf_item_name(sect)
                        local ps_name = get_hf_item_name(ps_sect)
                        
                        ps_data["consumers"][obj_id] = ps_wrapper:InitPDInfo(se_obj)
                        if ps_data["power_output"] - ps_data["consumers"][obj_id].watts_needed >= 0 then
                            ps_data["consumers"][obj_id].watts_satisfied = true
                            hf_obj_manager.update_data(ps_id, ps_data)
                            actor_menu.set_msg(1, gts("st_connect_device", pd_name, ps_name), 3)
                            dbg("dev", "connected %s to %s", obj_id, ps_id)
                            break
                        end
                    end
                end
            end
            -- MonkeyPatch | Remove connected power source and reset the power sources power output value
            local base_pickup = pd_wrapper.pickup
            pd_wrapper.pickup = function(self)
                local obj = self.object
                local id = obj:id()
                local sect = obj:section()
                dbg("info", "on pickup powerable device %s", id)
                if self.power_source_id then
                    local ps_data = hf_obj_manager.get_data(self.power_source_id)
                    local is_on = hf_obj_manager.get_data(id).is_on
                    if 
                        ps_data 
                        and contains(ps_data, "consumers", true)
                        and contains(ps_data["consumers"], id, true)
                    then
                        local curr_power_output = ps_data["power_output"]
                        local watts_needed = ps_data["consumers"][id].watts_needed
                        local new_power_output = is_on and curr_power_output - watts_needed or curr_power_output + watts_needed
                        if new_power_output <= ps_data["max_power_output"] then
                            dbg("dev", "resetting power output from %s to %s", curr_power_output, new_power_output)
                            ps_data["power_output"] = new_power_output
                        end

                        dbg("dev", "removing device:%s from source:%s", id, self.power_source_id)                        
                        ps_data["consumers"][id] = nil
                        hf_obj_manager.update_data(self.power_source_id, ps_data)
                    end
                end
                base_pickup(self)
            end
            pd_wrapper.init_pd = true
        end)
        return true
    end
end
]]

--[[

function on_place_powerable_device(obj_id)
    local se_obj = alife_object(obj_id)
    local sect = se_obj:section_name()
    local pos = se_obj.position or db.actor:position()
    
    if se_obj and is_power_consumer(sect) then
        dbg("info", "on place powerable device: %s", sect)
        for _, ps_sect in pairs(PLACEABLE_POWER_TRANSMITERS) do
            local found_power_sources = find_obj(ps_sect, pos, SEARCH_RADIUS)
            if is_not_empty(found_power_sources) then
                dbg("info", "found gens")
                for idx, found_ps in pairs(found_power_sources) do
                    local data = hf_obj_manager.get_data(found_ps:id())
                    if not contains(data["consumers"], obj_id, true) then
                        data["consumers"][obj_id] = sect
                        hf_obj_manager.update_data(found_ps:id(), data)
                        dbg("dev", "adding %s to powerable devices", get_hf_item_name(sect))
                    end
                end
            end
        end
    end
end

            wrapper.powered = false
            wrapper.power_source_id = nil

            wrapper.is_powered = function(self)
                local obj = self.object
                local id = obj:id()
                local sec = obj:section()
                --dbg("dev", "checking if %s is powered", id)
                local data = hf_obj_manager.get_data(id)
                if data then
                    if is_light(sec) then
                        dbg("all", "%s is powered?: %s", id, self.powered)
                        if 
                            self.powered and not data["is_on"]
                            or not self.powered and data["is_on"]
                        
                        then
                            data["is_on"] = false
                            dbg("all", "switching %s off", id)
                        end
                        self.last_state = data["is_on"]
                        hf_obj_manager.update_data(id, data)
                    end
                end
            end
            local base_update = wrapper.update
            wrapper.update = function(self, delta)
                -- dbg("dev", "updating powerable device binder")
                base_update(self, delta)
                if wrapper.is_powered then
                    wrapper.is_powered(self)
                end
            end
==============================
if is_not_empty(power_sources) then
        
        local not_connected_count = 0
        for _, obj in spairs(power_sources, function(t, a, b) return sort_obj_by_closest_pos(t, a, b, se_obj.position) end) do
            local found_ps = obj
            local found_ps_id = found_ps:id()
            local ps_data = hf_obj_manager.get_data(found_ps_id)
            local found_ps_sect = found_ps:section()
            local ps_name = get_hf_item_name(found_ps_sect)

            if 
                is_not_empty(ps_data["consumers"])
                and contains(ps_data["consumers"], obj_id, true)
            then
                local power_state = ps_data["power_state"]
                dbg("dev", "id:%s, sect:%s, power state: %s", found_ps_id, found_ps_sect, power_state)
                if power_state ~= "on" then -- off or broken
                    local is_on = hf_obj_manager.get_data(obj_id).is_on
                    if is_on then
                        dbg("dev", "switching off")
                        base_toggle_light(obj_id)
                        update_power_output(obj_id, found_ps_id)
                        return
                    end
                     local msg = gts("st_requires_power", ps_name, power_state, light_name)
                    actor_menu.set_msg(1, msg, 3)
                    dbg("dev", "%s", msg)
                    return
                end
            else
                not_connected_count = not_connected_count + 1
            end
        end

        if not_connected_count == #power_sources then
            dbg("dev", "%s is not connected to a power source", light_name)
            local msg = gts("st_needs_connecting", light_name)
            actor_menu.set_msg(1, msg, 3)
            return
        end
    end

    dbg("dev", "base toggle light")
    base_toggle_light(obj_id)
    local pd_wrapper = bind_hf_base.get_wrapper(obj_id)
    if pd_wrapper and pd_wrapper.power_source_id then
        update_power_output(obj_id, pd_wrapper.power_source_id)
    end
]]