--[[
    Last Edited: 08/04/25
    Author: antglobes
    Purpose: Adding Persistance Between Placeable Items and Inventory Items
--]]

-- Imports
ag_utils.import_metatable(this, ag_game_objects)
ag_utils.import_metatable(this, ag_npc)
ag_utils.import_metatable(this, ag_position)
ag_utils.import_metatable(this, ag_strings)
ag_utils.import_metatable(this, ag_tables)
gts = get_translation

-- External Imports
AOE = demonized_aoe.AOE

-- Utils
is_obj_visible = hfg_utils.is_object_visible
get_config = hfg_utils.get_config

-- Constants
GENERATOR_ITEMS = {
    "hfg_jerrycan_diesel",
    "hfg_jerrycan_diesel_empty"
}
MAX_FUEL = 60
SEARCH_RADIUS = 50
LOG_HEADER = "[HFG|Bind Gen Item]"

-- Variables
placed_generator_items = {}
local dbg_pr = nil

-- DEBUGGING
function setup_log(level, header, enabled)
    if not dbg_pr then
        dbg_pr = ag_logging.new({
            level=level,
            header=header,
            enabled=enabled
        })
    else
        dbg_pr:SetLevel(level)
        dbg_pr:Enable(enabled)
    end
end

function dbg(level, fmt, ...)
    if not dbg_pr then
        setup_log(get_config("debug_level"), LOG_HEADER, get_config("enable_debug"))    
    end
    dbg_pr:Log(level, fmt, ...)
end

function is_fuel_source(sect)
    return ini_sys:r_bool_ex(sect, "fuel_source", false)
end

function is_generator_item(sect)
    return contains(GENERATOR_ITEMS, sect) 
end

function is_placeable_item(sect)
    return ini_sys:r_string_ex(sect, "placeable_section") ~= nil
end

function init(obj)
    local id = obj:id()
    local sect = obj:section()
    dbg("debug", "init gen item binder, id: %s", id)
    local data = hf_obj_manager.get_data(id)
    if data then       
        if contains(data, "tbl_id", true) then
            local old = {id=data["tbl_id"], sect=data["item_section"]}
            local new = {id=id, sect=data["item_section"]}
            hfg_obj_persistance.replace(old, new)

        elseif contains(data, "is_world_obj", true) then
            data["tbl_id"] = id
            data["is_world_obj"] = false
            data["item_section"] = ini_sys:r_string_ex(sect, "item_section") or sect
            data["uses"] = data["item_section"] ~= "hfg_jerrycan_diesel_empty" and get_random_uses() or 0
            hfg_obj_persistance.init(id, data["item_section"], data)
        end
        hf_obj_manager.update_data(id, data)
    end
    obj:bind_object(placeable_generator_item_wrapper(obj).binder)
end

class "placeable_generator_item_wrapper" (bind_hf_base.hf_binder_wrapper)
function placeable_generator_item_wrapper:__init(obj) super(obj)
    local data = hf_obj_manager.get_data(self.object:id())
    dbg("dev", "%s", data)
    self.item_section = data["item_section"] or obj:section()
    self.condition = data["condition"] or  1
    self.uses = data["uses"] or obj:get_remaining_uses() or 0
    self:save_data()
end

function placeable_generator_item_wrapper:update(delta)
    bind_hf_base.hf_binder_wrapper.update(self, delta)
    self:load_data()

    local tg = time_global()

    if is_fuel_source(self.item_section) then
        if self.uses > 0 then
            if self.condition > 0 and self.condition < (self.uses / 10) then
                self.uses = self.uses - 1
                dbg("debug", "leaking, fuel left %s", self.uses)
                self:save_data()
            end
        end
        
        if 
            not contains(split(self.item_section, "_"), "empty") 
            and self.uses == 0 and self.condition <= 0.01 
        then
            dbg("debug", "exploding")
            local found_jerrycans = find_obj(self.object:section(), self.object:position(), 10)
            if is_not_empty(found_jerrycans) then
                for i=1, #found_jerrycans do
                    local obj = found_jerrycans[#found_jerrycans + 1 - i]
                    hf_obj_manager.update_data(obj:id(), {condition=0.01})
                end
            end
            
            AOE({
                position = self.object:position(),
                explosion_sound = "weapons\\explo\\dynamite_boom",
                aoe_sound = "anomaly\\fireball_idle",
                aoe_hit_sound = "anomaly\\fire2",
                explosion_particles = "explosions\\explosion_dynamite" ,
                explosion_damage = 2,    
                damage = 0.75,
                lifetime = 3,
                damage_period = 1.5 * 1000,
                can_panic_npc = true,
                draftsman_id = AC_ID
            })
            
            local data = hf_obj_manager.get_data(self.object:id())
            hfg_obj_persistance.remove(data["tbl_id"], data["item_section"])
            hf_obj_manager.cleanup_data(self.object:id())
            alife_release(self.object)
        end
    end

end

function placeable_generator_item_wrapper:pickup()
    dbg("debug", "on pickup")
    self:load_data()

    local se_obj
    if ini_sys:r_string_ex(self.item_section, "max_uses") ~= nil then
        se_obj = alife_create_item(self.item_section, db.actor, {cond=self.condition, uses=self.uses})
    else
        se_obj = alife_create_item(self.item_section, db.actor)
    end
    local data = hf_obj_manager.get_data(self.object:id())
    
    -- Find newly created se_obj, replace existing gen item tbl id with server obj id
    if data and contains(data, "tbl_id", true) then
        local old = {id=data["tbl_id"], sect=data["item_section"]}
        local new = {id=se_obj.id, sect=data["item_section"]}
        hfg_obj_persistance.replace(old, new)

        data["tbl_id"] = se_obj.id
        hf_obj_manager.update_data(se_obj.id, data)
    end
    dbg("dev", "picking up %s, giving %s uses", se_obj:section_name(), self.uses)

    hf_obj_manager.cleanup_data(self.object:id())
	alife_release(self.object)

    return true
end

function placeable_generator_item_wrapper:save_data()
    hf_obj_manager.update_data(self.object:id(), {
        item_section         = self.item_section,
        condition            = self.condition,
        uses                 = self.uses,
    })
end

function placeable_generator_item_wrapper:load_data()
    local data = hf_obj_manager.get_data(self.object:id())
    self.item_section         = data["item_section"]
    self.condition            = data["condition"]
    self.uses                 = data["uses"]
end


function add_fuel_cond(obj)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    local sect = obj:section()
    
    if not is_generator_item(sect) and not is_fuel_source(sect) then
        return false
    end

    local gen = level.get_target_obj()
    if gen and gen:section() == "placeable_disel_generator" then

        if distance_between(db.actor, gen) > 2 then
            hide_hud_inventory()
            actor_menu.set_msg(1, gts("st_no_gen_nearby"), 3)
            return false
        end

        local uses = hf_obj_manager.get_data(obj:id()).uses
        local power_state = hf_obj_manager.get_data(gen:id()).power_state
        return (uses and uses > 0) and power_state ~= "broken"
    end
    return false
    
end

function add_fuel_func(obj)
    local found_gen = level.get_target_obj()
    if not found_gen or (found_gen and found_gen:section() ~= "placeable_disel_generator") then return end
    local sect = obj:section()
    dbg("debug", "adding %s to diesel gen", sect)
    add_fuel(obj, found_gen:id())
end

function add_fuel(jerrycan, genny_id)
    
    local data = hf_obj_manager.get_data(jerrycan:id())
    local sect = jerrycan:section()
    local fuel_to_add = data["uses"]
    local stored_fuel = hf_obj_manager.get_data(genny_id).stored_fuel
    local is_jerrycan_empty = string.find(sect, "empty") and true or false
    dbg("dev", "adding fuel from %s: and adding it to genny", sect)
    dbg("dev", "is jerrycan empty: %s", is_jerrycan_empty)
    dbg("dev", "uses: %s", fuel_to_add)


    if stored_fuel == MAX_FUEL then return end
    if is_jerrycan_empty then return end
    if fuel_to_add == 0 then return end
    dbg("dev", "stored_fuel: %s", stored_fuel)

    if fuel_to_add + stored_fuel > MAX_FUEL then
        for i=1, fuel_to_add do
            fuel_to_add = fuel_to_add - 1
            if fuel_to_add + stored_fuel <= MAX_FUEL then
                break
            end
        end
    end
    dbg("dev", "fuel to add: %s", fuel_to_add)
    
    local remaining_uses = data["uses"] - fuel_to_add
    local transfer_occured = remaining_uses < data["uses"]
    data["uses"] = remaining_uses
    local update_id = jerrycan:id()
    utils_item.discharge(jerrycan, fuel_to_add)

    if remaining_uses == 0 then
        local empty_sect = ini_sys:r_string_ex(sect, "empty_sect")
        local se_obj = alife_create_item(empty_sect, db.actor)
        dbg("info", "creating %s", empty_sect)

        if data and contains(data, "tbl_id", true) then
            local old = {id=data["tbl_id"], sect=data["item_section"]}
            local new = {id=se_obj.id, sect=empty_sect}
            hfg_obj_persistance.replace(old, new)
            data["tbl_id"] = se_obj.id
            data["item_section"] = empty_sect
            update_id = se_obj.id
        end
    end
    dbg("info", "transfer occured: %s", transfer_occured)
    hf_obj_manager.update_data(update_id, data)
    hf_obj_manager.update_data(genny_id, {stored_fuel=(fuel_to_add + stored_fuel), fuel_transfer=transfer_occured})
end

function take_fuel_menu()
    return gts("st_take_fuel")
end

function take_fuel_cond(obj)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    local sect = obj:section()
    
    if not is_generator_item(sect) and not is_fuel_source(sect) then
        return false
    end

    local gen = level.get_target_obj()
    if gen and gen:section() == "placeable_disel_generator" then

        if distance_between(db.actor, gen) > 2 then
            hide_hud_inventory()
            actor_menu.set_msg(1, gts("st_no_gen_nearby"), 3)
            return false
        end

        local uses = hf_obj_manager.get_data(obj:id()).uses
        local power_state = hf_obj_manager.get_data(gen:id()).power_state
        return not uses or (uses and uses == 0) and power_state ~= "broken"
    end
    return false
end

function take_fuel_func(obj)
    local found_gen = level.get_target_obj()
    if not found_gen then
        dbg("dev", "generator not found")
        return
    end
    if (found_gen and found_gen:section() ~= "placeable_disel_generator") then
        dbg("dev", "power source is not disel generator: %s", found_gen:section())
        return 
    end

    if take_fuel_cond(obj) then
        take_fuel(obj, found_gen:id())
    end
end

function take_fuel(jerrycan, genny_id)
    local data = hf_obj_manager.get_data(jerrycan:id())
    local sect = jerrycan:section()
    local stored_fuel = hf_obj_manager.get_data(genny_id).stored_fuel
    local is_jerrycan_empty = string.find(sect, "empty") and true or false
    local uses = is_jerrycan_empty and 0 or data["uses"]
    local update_id = jerrycan:id()
    dbg("dev", "taking fuel from %s and adding it to genny", update_id)
    dbg("dev", "is jerrycan empty: %s", is_jerrycan_empty)
    dbg("dev", "uses: %s", uses)
    if stored_fuel <= 0 then return end
    if uses == 10 then return end

    local t_stored_fuel = math.floor(stored_fuel)
    dbg("dev", "stored_fuel: %s", t_stored_fuel)
    
    local fuel_to_take = is_jerrycan_empty and 10 or 10 - jerrycan:get_remaining_uses()
    if fuel_to_take == 0 then return end
    if t_stored_fuel - fuel_to_take < 0 then
        for i=1, fuel_to_take do
            fuel_to_take = fuel_to_take - 1
            if t_stored_fuel - fuel_to_take == 0 then
                break
            end
        end
    end
    dbg("dev", "fuel to take: %s", fuel_to_take)
    local new_uses = uses + fuel_to_take
    if new_uses > 0 then
        data["uses"] = new_uses
        
        if is_jerrycan_empty then
            local fuel_sect = "hfg_jerrycan_diesel"
            local se_obj = alife_create_item(fuel_sect, db.actor, {uses=new_uses})
            dbg("info", "creating new jerry can %s with uses: %s", se_obj.id, new_uses)
            if data and contains(data, "tbl_id", true) then
            local old = {id=data["tbl_id"], sect=data["item_section"]}
            local new = {id=se_obj.id, sect=fuel_sect}
            hfg_obj_persistance.replace(old, new)
                data["tbl_id"] = se_obj.id
                data["item_section"] = fuel_sect
                update_id = se_obj.id
            end
            if se_obj then alife_release(alife_object(jerrycan:id())) end
        else
            jerrycan:set_remaining_uses(new_uses)
        end
        local transfer_occured = new_uses >= uses
        dbg("dev", "transfer occured: %s", transfer_occured)
        hf_obj_manager.update_data(update_id, data)
        hf_obj_manager.update_data(genny_id, {stored_fuel=(stored_fuel - fuel_to_take), fuel_transfer=transfer_occured})
    end
end

-- Helper
function get_random_uses()
    math.randomseed(time_continual())
    local rnd = clamp(round_idp(math.random() + math.random(1, 100), 2), 0, 100)
    if rnd <= 25 then
        return math.random(1, 3)
    elseif rnd <= 50 then
        return math.random(1, 5)
    elseif rnd <= 75 then
        return math.random(1, 8)
    elseif rnd <= 100 then
        return math.random(1, 10)
    end
end

-- Monkey Patches
base_separate = bind_item.func_separate
function bind_item.func_separate(obj)
    dbg("debug", "on item separate")
    local id = obj:id()
    local sect = obj:section()
    local data = hf_obj_manager.get_data(id)
    if not data or not hfg_obj_persistance.in_cache(id, data["item_section"]) then
        dbg("dev", "base separate: %s", id)
        base_separate(obj)
        return
    end

	local uses = obj:get_remaining_uses()
	if uses and (uses > 1) then
		local se_obj = alife_create_item(sect, db.actor, {uses = 1})
		if se_obj then
            uses = uses - 1
			obj:set_remaining_uses(uses)
            hf_obj_manager.update_data(id, {uses=uses})

            local data = {
                id = se_obj.id,
                item_section = ini_sys:r_string_ex(sect, "item_section") or sect,
                uses = 1
            }
            hfg_obj_persistance.init(id, sect, data)
        end
    end
end

base_drag_drop = bind_item.on_item_drag_dropped
function bind_item.on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    dbg("debug", "on item drag dropped")
    if not (slot_from == EDDListType.iActorBag and slot_to == EDDListType.iActorBag) then
        return
    end

    local sec_1 = obj_1:section()
	local sec_2 = obj_2:section()

    if not is_generator_item(sec_1) then
        base_drag_drop(obj_1, obj_2, slot_from, slot_to)
        return
    end
	
	if not ((sec_1 == sec_2) and IsItem("multiuse",sec_1)) then
		return
	end

    local uses_1 = obj_1:get_remaining_uses()
	local uses_2 = obj_2:get_remaining_uses()
	local max_uses = obj_1:get_max_uses() 

	if not (uses_1 and uses_2 and max_uses) then
		return
	end

	local new_uses = uses_1 + uses_2
	if (new_uses > max_uses) then
		return
	end
	
	local id_1 = obj_1:id()
	local id_2 = obj_2:id()
	
    local se_obj = alife_object(id_1)
    if se_obj then
        dbg("info", "combining %s from %s uses to %s uses", sec_2, uses_2, new_uses)
        alife_release(se_obj)
        obj_2:set_remaining_uses(new_uses)
        local data = hf_obj_manager.get_data(id_2)
        hfg_obj_persistance.remove(data["tbl_id"], data["item_section"])
        hf_obj_manager.update_data(id_2, {uses=new_uses})
        itms_manager.play_item_sound(obj_2)
	end
end

base_func_tool = item_repair.func_tool
function item_repair.func_tool(obj)
    local found_generators = find_obj("placeable_disel_generator", db.actor:position(), SEARCH_RADIUS)
    local found_gen = get_nearest(found_generators)
    local gen_id = found_gen:id()
    if not found_gen or not is_obj_visible(gen_id) then
        base_func_tool(obj)
        return
    end
    dbg("debug", "opening repair ui")
    ui_diesel_generator.start_repair_ui(gen_id)
end

-- Callbacks
function on_item_take(obj)
    local id = obj:id()
    local sect = obj:section()
    if not is_generator_item(sect) or not is_placeable_item(sect) then return end
    if hfg_obj_persistance.in_cache(id, sect) then 
        dbg("error", "%s is in gen item tbl already", sect)
        return  
    end
    dbg("debug", "on item take: %s", sect)
    local data = {
        tbl_id=id,
        item_section = ini_sys:r_string_ex(sect, "item_section") or sect,
        uses = obj:get_remaining_uses() or 1
    }
    hfg_obj_persistance.init(id, sect, data)
end

function use_generator_item(obj)
    if add_fuel_cond(obj) then
        add_fuel_func(obj)
    end
end

function on_save(m_data)
    local t = {}
    copy_table(t, placed_generator_items)
    m_data.placed_generator_items = t
end

function on_load(m_data)
    local t = m_data.placed_generator_items or {}
    copy_table(placed_generator_items, t)
end

function update_jerrycan_cond(jc, cond, hit_damage)
    local loss_cond = cond - hit_damage
    cond = loss_cond > 0 and loss_cond or 0.01
    hf_obj_manager.update_data(jc:id(), {condition=cond})
end

function set_cond_on_impact(obj, wpn, ammo_count, grenade_count, ammo_type, grenade_type)
    if obj:id() ~= AC_ID then return end
    local target = level.get_target_obj()
    if not target then return end
    
    local targ_sect = target:section()
    local item_sect = ini_sys:r_string_ex(targ_sect, "item_section")
    if not item_sect then return end

    if not is_generator_item(item_sect) then return end
    if not is_fuel_source(item_sect) then return end
    dbg("dev", "on actor weapon fired: %s", item_sect)
    local data = hf_obj_manager.get_data(target:id())
    local wpn_sect = wpn:section()
    local cond = data and data["condition"] or 0
    local hit_damage = parse_list(ini_sys, wpn_sect, "hit_power")[1]
    dbg("info", "on impact jerrycan: %s, %s", cond, hit_damage)
    update_jerrycan_cond(target, cond, hit_damage)
end

function set_cond_on_explode(obj)
    local explo_sect = obj:section()
    dbg("debug", "explosive item on explode: %s", explo_sect)
    local found_objs = {}
    local function search(obj)
        local sect = obj:section()
        local item_sect = ini_sys:r_string_ex(sect, "item_section")
        if item_sect and item_sect == "hfg_jerrycan_diesel" then
            found_objs[#found_objs + 1] = obj
        end
    end

    local radius = ini_sys:r_float_ex(explo_sect, "blast_r")
    level.iterate_nearest(obj:position(), radius, search)

    if is_empty(found_objs) then return end
    for i=1, #found_objs do
        local jc = table.remove(found_objs, i)
        if jc then
            local data = hf_obj_manager.get_data(jc:id())
            local cond = data["condition"] or 1
            local hit_damage = ini_sys:r_float_ex(explo_sect, "blast_impulse") / 100
            dbg("dev", "on explode jerrycan: %s, %s", cond, hit_damage)
            update_jerrycan_cond(jc, cond, hit_damage)
        end
    end   
end

function set_cond_on_impact_npc(npc, wpn, target)
    if npc:id() == AC_ID then return end
    
    local targ_sect = target:section()
    local item_sect = ini_sys:r_string_ex(targ_sect, "item_section")
    if not item_sect then return end

    if not is_generator_item(item_sect) then return end
    if not is_fuel_source(item_sect) then return end
    dbg("debug", "on npc weapon fired: %s", item_sect)
    local data = hf_obj_manager.get_data(target:id())
    local wpn_sect = wpn:section()
    local cond = data["condition"] or 1
    local hit_damage = parse_list(ini_sys, wpn_sect, "hit_power")[1]
    dbg("info", "on impact jerrycan: %s, %s", cond, hit_damage)
    update_jerrycan_cond(target, cond, hit_damage)
end

function on_npc_fired(bullet)
    local sect = bullet.section
    local wpn_id = bullet.weapon_id
    local p_id = bullet.parent_id
    local t_id = bullet.target_id
    if p_id == AC_ID then return end

    local npc = get_unknown_object({id=p_id}, "game")
    local wpn = get_unknown_object({id=wpn_id}, "game")
    local target = get_unknown_object({id=t_id}, "game")

    if not (npc and wpn and target) then return end
    set_cond_on_impact_npc(npc, wpn, target)
end

function on_option_change(options)
    setup_log(options["debug_level"], LOG_HEADER, options["enable_debug"])
    SEARCH_RADIUS = options["power_source_search_radius"]
    MAX_FUEL = options["max_fuel"]
    dbg("debug", "Received options")
end

function on_game_start()
    RegisterScriptCallback("actor_on_item_take", on_item_take)
    RegisterScriptCallback("actor_on_item_use", use_generator_item)
    RegisterScriptCallback("save_state", on_save)
    RegisterScriptCallback("load_state", on_load)
    RegisterScriptCallback("actor_on_weapon_fired", set_cond_on_impact)
    -- RegisterScriptCallback("explosive_item_on_explode", set_cond_on_explode)
    RegisterScriptCallback("bullet_on_impact", on_npc_fired)
    RegisterScriptCallback("hfg_on_option_change", on_option_change)
end