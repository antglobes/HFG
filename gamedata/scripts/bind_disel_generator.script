-- Imports
get_unknown_object = hfg_utils.get_unknown_object
contains = hfg_utils.contains
gts = hfg_utils.get_translation
set_debug_level = hfg_utils.set_debug_level
get_sect_tbl = hfg_utils.get_sect_tbl
find_obj = hfg_utils.find_obj
get_nearest = hfg_utils.get_nearest
nearest_val = hfg_utils.nearest_val
print_table = hfg_utils.print_table
add_functor = custom_functor_autoinject.add_functor
get_keytable = hfg_utils.get_keytable
throttle = hfg_utils.throttle
find_inv_item = hfg_utils.find_inv_item
itr_inv = hfg_utils.itr_inv

-- Constants
SEARCH_RADIUS = 50
MIN_COND = 0.01
BROKEN_COND = 0.1
MAX_FUEL = 60
MAX_POWER_OUTPUT = 5000
SIPHON_RANGE = 3
JC_Y_DIFF = 114
BARREL_Y_DIFF = 288
OP_TXT = "Siphon %s from barrel"
FUEL_SECTIONS = {"batteries_dead"}
SWAP_POWER_STATE = {
    on = "off",
    off = "on",
    broken = "broken"
}
GENERATOR_ITEMS = {
    "hfg_jerrycan_diesel",
    "hfg_jerrycan_diesel_empty"
}
FUEL_TO_CLR = {
    jerrycan = {
        [0]   = {255, 255, 19, 18},
        [25]  = {255, 255, 19, 18}, 
        [50]  = {255, 255, 77, 18}, 
        [75]  = {255, 255, 242, 18},
        [100] = {255, 64, 253, 40},
    },
    barrel = {
        [0]   = {255, 255, 19, 18},
        [30]  = {255, 255, 19, 18}, --"red",
        [55]  = {255, 255, 77, 18}, --"orange",
        [80]  = {255, 255, 242, 18}, -- "yellow",
        [100] = {255, 64, 253, 40}, --"green"
    }
}

FUEL_TO_POS = {
    jerrycan = {
        [0]   = 339,
        [25]  = 311,
        [50]  = 282,
        [75]  = 254,
        [100] = 225,
    },
    barrel = {
        [0]   = 333,
        [30]  = 239, --"red",
        [55]  = 189, --"orange",
        [80]  = 95,  -- "yellow",
        [100] = 45, --"green"
    }
}


-- Variables
GUI = nil
placed_generator_items = {}
fuel_barrels = {}


-- DEBUGGING
function pr(str, ...)
    hfg_utils.dbg_pr("[HFG|Bind Disel Gen]: %s", str, ...)
end

function toggle_power(obj_id)
    pr("Toggle Genny Power")
    local data = hf_obj_manager.get_data(obj_id)
    --pr("Genny data: %s\n", utils_data.print_table(data, nil, true))
    local in_progress = data["anim_in_progress"]
    if in_progress then pr("anim in progress, cant switch power state") return end

    local no_fuel = data["stored_fuel"] == 0
    if no_fuel then
        pr("no fuel")
        actor_menu.set_msg(1, gts("st_no_fuel"), 3)
        return
    end

    local power_state = data["power_state"]
    if power_state then
        if power_state == "broken" then 
            actor_menu.set_msg(1, gts("st_generator_broken"), 3)
            return 
        end
        local obj = get_unknown_object({id=obj_id}, "game")
        if obj then
            pr("Switching interact tip to %s", power_state)
            obj:set_tip_text(gts("st_power_state_" .. power_state))
        end
        pr("Attempting to switch power from %s to %s", power_state, SWAP_POWER_STATE[power_state])
        hf_obj_manager.update_data(obj_id, {power_state=SWAP_POWER_STATE[power_state], last_power_state=power_state, anim_due=true})
        return
    end
    pr("genny left in current state")
end

-- Diesel Generator Binder

function init(obj)
    pr("Initalising genny")
    obj:bind_object(placeable_disel_generator_wrapper(obj).binder)
end

class "placeable_disel_generator_wrapper" (bind_hf_base.hf_binder_wrapper)
function placeable_disel_generator_wrapper:__init(obj) super(obj)
    
    local data = hf_obj_manager.get_data(self.object:id())

    -- Object Fields
    self.section = self.object:section()
    self.condition = contains(data, "condition", true) and data["condition"] or 1
    
    -- Object State
    self.power_state = self.condition > BROKEN_COND and (data["power_state"] or "off") or "broken"
    self.object:set_tip_text(gts("st_power_state_" .. SWAP_POWER_STATE[self.power_state]))
    self.current_motion = "idle"
    self.powerable_device_tmr = 0

    -- Animation State
    self.anim_due = data["anim_due"] or false
    self.anim_in_progress = data["anim_in_progress"] or false
    self.anim_stage = data["anim_stage"] or 1
    self.anim_state = data["anim_state"] or ""
    self.anim_power_state = data["anim_power_state"] or ""

    -- Animation snd
    self.snd = data["snd"] or {}
    self.snd["last_played"] = contains(data["snd"], "last_played", true) and data["snd"]["last_played"] or nil

    -- Animation Time
    self.anim_tmr = data["anim_tmr"] or 0

    -- Animation tbl
    self.anim_tbl = data["anim_tbl"] or {
        on = {
            [1] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start",              },
            [2] = {anim="work",     duration=6, snd="ambient\\pripyat\\pri_b306_generator_start"},
            [3] = {anim="work_2x",  duration=0, snd="ambient\\pripyat\\pri_b306_generator_work"}
        },
        off = {
            [1] = {anim="work",     duration=6, snd="ambient\\pripyat\\pri_b306_generator_work"},
            [2] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start"},
            [3] = {anim="idle",     duration=0, snd="device\\bridge\\motor_stop"}
        },
        broken = {
            [1] = {anim="work_2x",  duration=5, snd="weapons\\explo\\dynamite_boom"},
            [2] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start"},
            [3] = {anim="idle",     duration=0, snd="device\\bridge\\motor_stop"}
        }
    }

    -- Particles

    self.last_cond_state = data["last_cond_state"] or ""
    self.curr_fx = data["curr_fx"] or {}
    self.fx_tbl = { -- rpt = repeat, slp = sleep
        broken = {
            [1] = {part="explosions\\expl_car_smoke_big",                duration={active=13,  pause=2, rpt=1},                  bone_name="exhaust", count=0, loop=false, active=false, tmr=0},
            [2] = {part="explosions\\explosion_dynamite",                duration={active=1.2, pause=3.8, rpt=1},        bone_name="body",    count=0, loop=false, active=false, tmr=0},
        },
        low = {
            [1] = {part="explosions\\expl_car_smoke_small",              duration={active=13, pause=2},                  bone_name="r_rotor", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="explosions\\campfire_hot_no_fire",              duration={active=1, pause=0.5, rpt=5, slp=60},  bone_name="r_rotor", count=0, loop=true,  active=false, tmr=0},
            [3] = {part="vehiclefx\\niva_damagedexhaust_01",             duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        },
        med = {
            [1] = {part="vehiclefx\\generic_exhaust_01",                 duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="vehiclefx\\exhaust_kamaz",                      duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        },
        high = {
            [1] = {part="vehiclefx\\exhaust_1",                          duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="vehiclefx\\niva_damagedexhaust_01",             duration={active=1, pause=0.5, rpt=5},          bone_name="exhaust", count=0, loop=false, active=false, tmr=0},
            [3] = {part="industrial_particles\\exhaust_workshop_1",      duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        }
    }

    -- Powerable Devices
    self.power_off_devices = true
    self.powerable_devices = {} -- get_powerable_devices(self.object:position())
    self.power_output = data["power_output"] or MAX_POWER_OUTPUT
    self.connected_devices = data["connected_devices"] or 0

    -- Fuel
    self.stored_fuel = data["stored_fuel"] or 0
    self.max_fuel = data["max_fuel"] or MAX_FUEL
    self.fuel_transfer = data["fuel_transfer"] or false
    self.time_til_empty = data["time_til_empty"] or 0
    self.drain_rate = {
        [0.5]  = 1.2,
        [0.75] = 1.48,
        [1]    = 2
    }
    pr("saving data")
    self:save_data()
    pr("finished init")
end

function placeable_disel_generator_wrapper:update(delta)
    bind_hf_base.hf_binder_wrapper.update(self, delta)

    self.tg = time_global()
    self:load_data()

    local condition = self.condition
    local cond_state = cond_to_state(round_idp(condition * 100, 2))
    
    -- Process Power Output
    if self.power_state == "on" then
        self.power_output = MAX_POWER_OUTPUT * round_idp(condition * 100, 2)
    elseif contains({"off", "broken", self.power_state}) then
        self.power_output = 0
    end
    
    self.ProcessPowerState(cond_state)
    self:ProcessParticles(cond_state)
    self:ProcessAnims()
    self:ProcessPowerableDevices()
    self:ProcessFuel()
end

function placeable_disel_generator_wrapper:ProcessPowerState(cond_state)
    -- On Power State Switch
    if self.last_power_state ~= self.power_state then
        pr("processing power state")
        self.object:set_tip_text(gts("st_power_state_" .. SWAP_POWER_STATE[self.power_state]))
        if self.power_state == "broken" and cond_state == "broken" then
            if not self.anim_in_progress and self.current_motion ~= "idle" then
                self.anim_due = true
            end
        end
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:ProcessParticles(cond_state)
    if self.power_state == "on" or (self.power_state == "broken" and self.current_motion ~= "idle") then
        -- If Condition Has Changed enough for a particle update
        if cond_state ~= self.last_cond_state then
            pr("cond state: %s", cond_state)
            -- If there are particles currently playing, stop them, update curr fx
            if is_not_empty(self.curr_fx) and contains(self.curr_fx, self.last_cond_state) then
                local fx = self.curr_fx[self.last_cond_state]
                for idx, details in pairs(fx) do
                    if details["active"] and contains(details, "id", true) then
                        thial_particles.remove(details["id"])
                    end
                end
            end
            
            self.curr_fx[cond_state] = self.fx_tbl[cond_state]
            self.last_cond_state = cond_state
        end

        for idx, details in pairs(self.curr_fx[self.last_cond_state]) do
            if self.tg > details["tmr"] then
                if not details["active"] then                    
                    self.curr_fx[self.last_cond_state][idx].tmr = self.tg + (details["duration"]["active"] * 1000)
                    self.curr_fx[self.last_cond_state][idx].active = true
                    --pr("exhaust pos: %s", vec_to_str(self.exhaust_pos))
                    self.curr_fx[self.last_cond_state][idx].id = thial_particles.add(details["part"], get_bone_pos(self.object, details["bone_name"]), (details["duration"]["active"]*1000))
                    if details["bone_name"] == "exhaust" then
                        pr("setiting part dir to be exhaust dir")
                        local part_obj = thial_particles.get(self.curr_fx[self.last_cond_state][idx].id)
                        local exhaust_pos = get_bone_pos(self.object, "exhaust")
                        local link_pos =  get_bone_pos(self.object, "body")
                        local dx = exhaust_pos.x - link_pos.x
                        local dy = exhaust_pos.y - link_pos.y
                        local dz = exhaust_pos.z - link_pos.z
                        local length = math.sqrt(math.pow(dx, 2)) + math.sqrt(math.pow(dy, 2)) + math.sqrt(math.pow(dz, 2))
                        local nx = dx/length
                        local ny = dy/length
                        local nz = dz/length
                        local norm_dir = vector():set(nx, ny, nz)
                        --pr("dir: %s", vec_to_str(norm_dir))
                        part_obj:set_direction(norm_dir)
                    end
                    pr("Playing particle: %s for %s", details["part"], details["duration"]["active"])
                elseif details["active"] then
                    local remove_particle = false

                    if details["duration"]["pause"] then
                        self.curr_fx[self.last_cond_state][idx].tmr = self.tg + (details["duration"]["pause"] * 1000)
                        self.curr_fx[self.last_cond_state][idx].active = false
                        pr("pausing %s for %s", details["part"], details["duration"]["pause"])
                        if details["duration"]["rpt"] then
                            self.curr_fx[self.last_cond_state][idx].count = self.curr_fx[self.last_cond_state][idx]["count"] + 1
                            pr("advancing repeat: %s", self.curr_fx[self.last_cond_state][idx].count)
                            if self.curr_fx[self.last_cond_state][idx]["count"] >= details["duration"]["rpt"] then
                                if not details["loop"] then
                                    pr("particle finished cycle")
                                    self.curr_fx[self.last_cond_state][idx].tmr = 0
                                    self.curr_fx[self.last_cond_state][idx].count = 0
                                    --self.curr_fx[self.last_cond_state][idx].active = false
                                    id = self.curr_fx[self.last_cond_state][idx]["id"]
                                    self.curr_fx[self.last_cond_state][idx] = nil
                                    remove_particle = true
                                    if self.last_cond_state == "broken" and self.current_motion ~= "idle" then
                                        self.anim_due = true
                                        self.power_state = self.last_cond_state
                                    end
                                elseif details["loop"] and details["duration"]["slp"] then
                                    pr("particle %s reached end of loop putting to sleep for %s", details["part"], details["duration"]["slp"])
                                    self.curr_fx[self.last_cond_state][idx].tmr = self.tg + details["duration"]["slp"]
                                end
                            end
                        end                    
                    else
                        pr("reseting particle")
                        self.curr_fx[self.last_cond_state][idx].tmr = 0
                        self.curr_fx[self.last_cond_state][idx].active = false
                    end

                    if remove_particle then
                        pr("removing particle")
                        thial_particles.remove(id)
                    end
                
                end
            end
            self:save_data()
        end

    elseif self.power_state == "off" then        
        self:CleanupParticles()
    end
end

function placeable_disel_generator_wrapper:ProcessAnims()
    if self.anim_due then
        if not self.anim_in_progress then
            pr("Setting Anim Control Vars")
            self.anim_in_progress = true
            self.anim_power_state = self.power_state
            self.anim_start_time = self.tg
            self:CleanupParticles()
            pr("anim power state: %s", self.anim_power_state)
        end

        -- Prevent Toggle Power being constantly pressed from interrupting an animation
        if self.anim_in_progress and self.anim_power_state ~= self.power_state then
            pr("Attempted to change power state during anim, using anim set power state")
            self.power_state = self.anim_power_state
            --pr("power state: %s", self.power_state)
        end

        -- End Process if Animation Time not reached
        if self.tg < self.anim_tmr then
            return
        end
        pr("Anim Time Reached")
        -- If Anim Gets stuck and/or has exceed it's animation time whilst a cond changes reset it/ move to next stage
        if self.tg > self.anim_tmr and self.tg - self.anim_start_time > self.anim_tmr then
            pr("Anim Runtime Exceed, Advancing Stage")
            self.anim_tmr = 0
            self.anim_stage = self.anim_stage + 1
        end

        -- Stop Animation and Reset Controllers
        pr("Anim stage %s, total stages %s", self.anim_stage, #self.anim_tbl[self.power_state])
        if self.anim_stage > #self.anim_tbl[self.power_state] then
            pr("stopping anim")
            self.anim_due = false
            self.anim_in_progress = false
            self.anim_tmr = 0
            self.anim_stage = 1
            self.power_off_devices = contains({"off", "broken"}, self.power_state)
            self:save_data()
            return
        end

        pr("Starting Anim Stage %s at %s", self.anim_stage, self.tg)
        -- Play Animation for given duration and advance/save animation
        local details = self.anim_tbl[self.power_state][self.anim_stage]        
        local snd_props = sound_object.s3d + sound_object.looped
        local last_stage = #self.anim_tbl[self.power_state]
        if self.anim_stage < last_stage or self.anim_stage == last_stage and contains({"off", "broken"}, self.power_state) then
            --pr("Not looping snd")
            snd_props = sound_object.s3d
        end

        if self.snd["last_played"] ~= nil  then
            ag_sounds.remove(self.snd["last_played"])
            pr("Stopping last played snd. Played for %s", self.tg - self.anim_tmr)
        end
        if details["snd"] then
            self.snd["last_played"] = ag_sounds.add(self.object, details["snd"], self.object:position(),  0.7, snd_props)
            pr("playing sound %s", details["snd"])
        end
        pr("Starting to play %s at %s", details["anim"], self.tg)

        self.object:play_cycle(details["anim"])
        --self:UpdateAnimData(details["anim"])
        self.current_motion = details["anim"]
        pr("setting current motion to %s", details["anim"])
        self.anim_tmr = self.tg + (details["duration"] * 1000)
        pr("setting next anim time to %s", self.anim_tmr)
        self.anim_stage = self.anim_stage + 1
        pr("advancing anim stage to: %s", self.anim_stage)
        self:save_data()
        pr("saved data")
    end
end

function placeable_disel_generator_wrapper:ProcessPowerableDevices()
    if self.tg > self.powerable_device_tmr then
        pr("updating fuel")
        local powerable_devices = get_powerable_devices(self.object:position())
        if is_not_empty(powerable_devices) then
            for id, sect in pairs(powerable_devices) do
                local data = hf_obj_manager.get_data(id)
                if data["is_on"] then
                    if contains(data, "fuel", true) and not contains(data, "infinite_fuel", true) and data["fuel"] < 0.95 then
                        hf_obj_manager.update_data(id, {fuel=1})
                        self.connected_devices = self.connected_devices + 1
                    end
                end
            end
        end
        self.powerable_device_tmr = self.tg + (3600 * 1000)
        self:save_data()
    end

    if self.power_off_devices then
        pr("turning off devices")
        local extra_powerable_devices = get_powerable_devices(self.object:position())
        if is_not_empty(extra_powerable_devices) then
            for id, sect in pairs(extra_powerable_devices) do
                if not contains(self.powerable_devices, id, true) then
                    self.powerable_devices[id] = sect
                end
            end
        end

        for id, sect in pairs(self.powerable_devices) do
            hf_obj_manager.update_data(id, {is_on=false})
            self.connected_devices = self.connected_devices - 1
        end
        self.power_off_devices = false
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:ProcessFuel()
    if self.stored_fuel == 0 then
        if self.power_state == "on" and not self.anim_in_progress then
            pr("no fuel switching off")
            self.power_state = "off"
            self.anim_due = true
        end
        return
    end

    local percent_full = self.stored_fuel / self.max_fuel
    local drain_rate = get_keytable(self.drain_rate )
    local fuel_load = nearest_val(drain_rate, percent_full)

    if self.fuel_transfer then
        pr("resesting time til empty")
        self.time_til_empty = self.tg + (self.stored_fuel / self.drain_rate[fuel_load]) * (3600 * 1000)
        pr("stored fuel: %s", self.stored_fuel)
        pr("time_til_empty: %s", self.time_til_empty)
        self.fuel_transfer = false
    end

    local drain_rate_second = self.drain_rate[fuel_load] / 3600 
    self.stored_fuel = self.stored_fuel - drain_rate_second
    self.time_til_empty = self.time_til_empty - 1000
    self:save_data()
end

function placeable_disel_generator_wrapper:UpdateAnimData(anim_name)
    pr("Updating anim data for id:%s", self.object:id())
    local se_obj = alife_object(self.object:id())
    if se_obj then
        local data = utils_stpk.get_physic_data(se_obj)
        pr("From %s to %s", data["skeleton_name"], anim_name)
        data.skeleton_name = anim_name
        utils_stpk.set_physic_data(data, se_obj)
    end
end

function placeable_disel_generator_wrapper:CleanupParticles()
    if is_not_empty(self.curr_fx) and contains(self.curr_fx, self.last_cond_state) then
        pr("power off removing particles")
        local fx = self.curr_fx[self.last_cond_state]
        for idx, details in pairs(fx) do
            if details["active"] and contains(details, "id", true) then
                thial_particles.remove(details["id"])
            end
        end
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:GetGenInfo()
    return {
        condition         = self.condition,
        stored_fuel       = self.stored_fuel,
        time_til_empty    = self.time_til_empty,
        power_output      = self.power_output,
        connected_devices = self.connected_devices
    }
end

function placeable_disel_generator_wrapper:pickup()
    pr("on pickup")
    self:load_data()
    local item_section = ini_sys:r_string_ex(self.object:section(), "item_section")
    pr("binder cond: %s", self.condition)
    local se_obj = alife_create(item_section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, false)
    local data = utils_stpk.get_item_data(se_obj)
    data.condition = self.condition
    utils_stpk.set_item_data(data, se_obj)
    alife():register(se_obj)

    -- Clean up HF-related data
    hf_obj_manager.cleanup_data(self.object:id())
	alife_release(self.object)
    return true
end

function placeable_disel_generator_wrapper:net_destroy()
    pr("on net destory")
    self:save_data()
    if self.snd and contains(self.snd, "last_played", true) then
        local id = self.snd["last_played"]
        ag_sounds.remove(id)
        self.snd["last_played"] = nil
    end

    self:CleanupParticles()
end

function placeable_disel_generator_wrapper:save_data()
    --pr("save data")
    hf_obj_manager.update_data(self.object:id(), {
        power_state          = self.power_state,
        anim_due             = self.anim_due,
        anim_in_progress     = self.anim_in_progress,
        anim_stage           = self.anim_stage,
        anim_state           = self.anim_state,
        anim_tmr             = self.anim_tmr,
        anim_tbl             = self.anim_tbl,
        anim_power_state     = self.anim_power_state,
        snd                  = self.snd,
        last_cond_state      = self.last_cond_state,
        curr_fx              = self.curr_fx,
        fx_tbl               = self.fx_tbl,
        condition            = self.condition,
        powerable_devices    = self.powerable_devices,
        power_off_devices    = self.power_off_devices,
        current_motion       = self.current_motion,
        anim_start_time      = self.anim_start_time,
        last_power_state     = self.last_power_state,
        powerable_device_tmr = self.powerable_device_tmr,
        power_output         = self.power_output,
        connected_devices    = self.connected_devices,
        stored_fuel          = self.stored_fuel,
        max_fuel             = self.max_fuel,
        fuel_transfer        = self.fuel_transfer,
        time_til_empty       = self.time_til_empty,
        drain_rate           = self.drain_rate,
    })
    --pr("Genny data: %s\n", print_table(data))
end

function placeable_disel_generator_wrapper:load_data()
    --pr("on load")
    local data = hf_obj_manager.get_data(self.object:id())
    self.power_state          = data["power_state"]
    self.anim_due             = data["anim_due"]
    self.anim_in_progress     = data["anim_in_progress"]
    self.anim_stage           = data["anim_stage"]
    self.anim_state           = data["anim_state"]
    self.anim_tmr             = data["anim_tmr"]
    self.anim_tbl             = data["anim_tbl"]
    self.anim_power_state     = data["anim_power_state"]
    self.snd                  = data["snd"]
    self.last_cond_state      = data["last_cond_state"]
    self.curr_fx              = data["curr_fx"]
    self.fx_tbl               = data["fx_tbl"]
    self.condition            = data["condition"]
    self.powerable_devices    = data["powerable_devices"]
    self.power_off_devices    = data["power_off_devices"]
    self.current_motion       = data["current_motion"]
    self.anim_start_time      = data["anim_start_time"]
    self.last_power_state     = data["last_power_state"]
    self.powerable_device_tmr = data["powerable_device_tmr"]
    self.power_output         = data["power_output"]
    self.connected_devices    = data["connected_devices"]
    self.stored_fuel          = data["stored_fuel"]
    self.max_fuel             = data["max_fuel"]
    self.fuel_transfer        = data["fuel_transfer"]
    self.time_til_empty       = data["time_til_empty"]
    self.drain_rate           = data["drain_rate"]

    --pr("Genny data: %s\n", utils_data.print_table(data, nil, true))
end

-- Generator UI
function start_ui(obj_id)
    if not GUI then
        GUI = UIDieselGenerator()
    end

    if GUI and not GUI:IsShown() then
        GUI:Reset(obj_id)
        GUI:ShowDialog(true)
        Register_UI("UIDieselGenerator")
    end
end

class "UIDieselGenerator" (CUIScriptWnd)
function UIDieselGenerator:__init(obj_id) super(obj_id)
    self.gen_id = obj_id

end

function UIDieselGenerator:InitControls()

end

function UIDieselGenerator:InitCallbacks()

end

function UIDieselGenerator:Reset(obj_id)

end

function UIDieselGenerator:Close()

end

function UIDieselGenerator:Update()

end

function UIDieselGenerator:Pickup()

end

function UIDieselGenerator:TogglePower()
    toggle_power(self.gen_id)
end


-- Binder Helpers

function get_bone_pos(obj, bone_name)    
    local bid = obj:get_bone_id(bone_name)
    local bpos = obj:bone_position(bid)
    --pr("%s pos: %s", bone_name, vec_to_str(bpos))
    return bpos
end

function cond_to_state(cond)
    local state = "high"
    if cond <= 10 then
        state = "broken"
    elseif cond <= 35 then
        state = "low"
    elseif cond <= 80 then
        state = "med"
    elseif cond <= 100 then
        state = "high"
    end
    return state
end

-- Generator Condition 

function update_gen_cond(gen, cond, power_state, hit_damage)
    if power_state ~= "broken" then
        local anim_due = false
        local loss_cond = cond - hit_damage
        cond = loss_cond > 0 and loss_cond or MIN_COND

        pr("updating cond: %s", cond)
        if cond > BROKEN_COND then
            hf_obj_manager.update_data(gen:id(), {condition=cond}) 
        else
            if power_state == "on" then
                anim_due = true
            end
            hf_obj_manager.update_data(gen:id(), {
                condition=cond,
                last_power_state=power_state,
                power_state="broken",
                anim_due=anim_due
            }) 
        end
    end
end

function set_cond_on_explode(obj)
    local explo_sect = obj:section()
    pr("explosive_item_on_explode: %s", explo_sect)
    local found_objs = {}
    local function search(obj)
        local sect = obj:section()
        if is_not_empty({string.find(sect, "disel_generator")}) then
            pr("found genny: %s", sect)
            found_objs[#found_objs + 1] = obj
        end
    end

    local radius = ini_sys:r_float_ex(explo_sect, "blast_r")
    level.iterate_nearest(obj:position(), radius, search)

    if is_empty(found_objs) then return end
    for i=1, #found_objs do
        local gen = table.remove(found_objs, i)
        if gen then
            local data = hf_obj_manager.get_data(gen:id())
            local power_state = data["power_state"]
            local cond = data["condition"] or 1
            local hit_damage = ini_sys:r_float_ex(explo_sect, "blast_impulse") / 100
            -- shoot a ray from obj to genny
            -- if hit any material get material
            -- check to see how much the material would absorb the damage
            -- apply to cond
            update_gen_cond(gen, cond, power_state, hit_damage)
        end
    end   
end

function set_cond_on_impact(obj, wpn, ammo_count, grenade_count, ammo_type, grenade_type)
    if obj:id() ~= AC_ID then return end
    local target = level.get_target_obj()
    if not target then return end
    local target_sect = target:section()
    if is_empty({string.find(target_sect, "placeable_disel_generator")}) then return end
    local wpn_sect = wpn:section()
    local data = hf_obj_manager.get_data(target:id())
    local power_state = data["power_state"]
    local cond = data["condition"] or 1
    local hit_damage = parse_list(ini_sys, wpn_sect, "hit_power")[1]
    pr("on impact: %s", wpn_sect)
    update_gen_cond(target, cond, power_state, hit_damage)
end

-- Generator Items

function is_fuel_source(sect)
    return ini_sys:r_bool_ex(sect, "fuel_source", false)
end

function is_generator_item(sect)
    return contains(GENERATOR_ITEMS, sect) 
end

function is_placeable_item(sect)
    return ini_sys:r_string_ex(sect, "placeable_section") ~= nil
end

function is_in_generator_item_tbl(id)
    --pr("id: %s, gen tbl: %s\\n", id, print_table(placed_generator_items))
    for kind, _ in pairs(placed_generator_items) do
        if contains(placed_generator_items[kind], id, true) then
            return true
        end
    end
    return false
end

function init_generator_item(tbl)
    local id = tbl["id"]
    local sect = tbl["sect"]
    local uses = tbl["uses"]
    if contains(tbl, "obj", true) then
        local obj = tbl["obj"]
        id = obj:id()
        sect = obj:section()
        uses = obj:get_remaining_uses()
    end
    pr("init gen item")
    if is_fuel_source(sect) then
        pr("is fuel source")
        if not contains(placed_generator_items, "fuel_sources", true) then
            placed_generator_items["fuel_sources"] = {}
        end
        if not contains(placed_generator_items["fuel_sources"], id, true) then
            placed_generator_items["fuel_sources"][id] = sect
        end
        
        local item_section = ini_sys:r_string_ex(sect, "item_section") or sect
        local data = {tbl_id=id, item_section=item_section, uses=uses}
        if is_not_empty({string.find(sect, "empty")}) then
            data["uses"] = nil
        end
        hf_obj_manager.set_data(id, data)
    end
end

function replace_generator_item(old_id, new_id)
    for kind, _ in pairs(placed_generator_items) do
        if contains(placed_generator_items[kind], old_id, true) then
            pr("replacing %s to %s", old_id, new_id)
            local info = placed_generator_items[kind][old_id]
            placed_generator_items[kind][new_id] = info
            placed_generator_items[kind][old_id] = nil
            hf_obj_manager.delete_data(old_id)
        end
    end
end

function update_generator_item(id, info)
    for kind, info in pairs(placed_generator_items) do
        if contains(placed_generator_items[kind], id, true) then
            for k, v in pairs(info) do
                pr("%s info: %s", kind, print_table(info))
                if contains(placed_generator_items[kind][id], k, true) then
                    pr("updating %s's %s to %v", id, k, v)
                    placed_generator_items[kind][id][k] = v
                end
            end
        end
    end
end

function remove_generator_item(id)
    if not is_in_generator_item_tbl(id) then 
        pr("Cannot remove id %s from generator item tbl, not present: %s", id)
        return
    end
    local idx
    for kind, info in pairs(placed_generator_items) do
        if contains(info, id, true) then
            idx = kind
        end
    end
    if idx then
        pr("removing %s from generator item tbl", id)
        placed_generator_items[idx][id] = nil
    end
end

function bind_generator_item(obj)
    local id = obj:id()
    pr("init gen item binder, id: %s", id)
    local data = hf_obj_manager.get_data(id)

    if data and contains(data, "tbl_id", true) then
        replace_generator_item(data["tbl_id"], id)
        data["tbl_id"] = id
        hf_obj_manager.update_data(id, data)
    end
    obj:bind_object(placeable_generator_item_wrapper(obj).binder)
end

class "placeable_generator_item_wrapper" (bind_hf_base.hf_binder_wrapper)
function placeable_generator_item_wrapper:__init(obj) super(obj)
    local data = hf_obj_manager.get_data(self.object:id())
    --pr("data: %s", print_table(data))
    self.item_section = data["item_section"]
    self.condition = data["condition"] or 1
    self.uses = data["uses"]

    self:save_data()
end

function placeable_generator_item_wrapper:pickup()
    pr("on pickup")
    self:load_data()

    local se_obj
    if ini_sys:r_string_ex(self.item_section, "max_uses") ~= nil then
        se_obj = alife_create_item(self.item_section, db.actor, {cond=self.condition, uses=self.uses})
    else
        se_obj = alife_create_item(self.item_section, db.actor)
    end
    local data = hf_obj_manager.get_data(self.object:id())
    
    -- Find newly created se_obj, replace existing gen item tbl id with server obj id
    if data and contains(data, "tbl_id", true) then
        replace_generator_item(data["tbl_id"], se_obj.id)
        data["tbl_id"] = se_obj.id
        hf_obj_manager.update_data(se_obj.id, data)
    end
    pr("picking up %s, giving %s uses", se_obj:section_name(), self.uses)

    hf_obj_manager.cleanup_data(self.object:id())
	alife_release(self.object)

    return true
end

function placeable_generator_item_wrapper:save_data()
    hf_obj_manager.update_data(self.object:id(), {
        item_section         = self.item_section,
        condition            = self.condition,
        uses                 = self.uses,
    })
end

function placeable_generator_item_wrapper:load_data()
    local data = hf_obj_manager.get_data(self.object:id())
    self.item_section         = data["item_section"]
    self.condition            = data["condition"]
    self.uses                 = data["uses"]
end

function add_fuel_cond(obj)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    local sect = obj:section()
    local found_gens = find_obj("placeable_disel_generator", db.actor:position(), 0.5)
    local gen_nearby = is_not_empty(found_gens)
    if not gen_nearby then
        actor_menu.set_msg(1, gts("st_no_gen_nearby"), 3)
    end
    local uses = hf_obj_manager.get_data(obj:id()).uses
    return is_generator_item(sect) and is_fuel_source(sect) and (uses and uses > 0) and gen_nearby
end

function add_fuel_func(obj)
    local found_gens = find_obj("placeable_disel_generator", db.actor:position(), 0.5)
    local found_gen = get_nearest(found_gens)
    local sect = obj:section()
    pr("adding %s to diesel gen", sect)
    local data = hf_obj_manager.get_data(obj:id())
    local uses = data["uses"]
    local fuel_to_add = uses
    local wrapper = found_gen:binded_object().wrapper
    local stored_fuel = wrapper.stored_fuel

    if stored_fuel >= MAX_FUEL then
        hide_hud_inventory()
        actor_menu.set_msg(1, gts("st_max_fuel"), 3)
        return
    end
    pr("stored fuel: %s", stored_fuel)
    pr("calculating fuel to transfer")
    if fuel_to_add + stored_fuel > MAX_FUEL then
        for i=1, fuel_to_add do
            fuel_to_add = fuel_to_add - 1
            if fuel_to_add + stored_fuel <= MAX_FUEL then
                break
            end
        end
    end
    pr("adding %sL to genny", fuel_to_add)

    local remaining_uses = uses - fuel_to_add
    data["uses"] = remaining_uses
    pr("remaining uses: %s", remaining_uses)

    local update_id = obj:id()
    utils_item.discharge(obj, fuel_to_add)
    if remaining_uses == 0 then
        local empty_sect = ini_sys:r_string_ex(sect, "empty_sect")
        local se_obj = alife_create_item(empty_sect, db.actor)
        if data and contains(data, "tbl_id", true) then
            replace_generator_item(data["tbl_id"], se_obj.id)
            data["tbl_id"] = se_obj.id
            data["item_section"] = empty_sect
            update_id = se_obj.id
        end
        pr("creating %s", empty_sect)
    end
    local transfer_occured = remaining_uses < uses
    hf_obj_manager.update_data(update_id, data)
    hf_obj_manager.update_data(found_gen:id(), {stored_fuel=(fuel_to_add + stored_fuel), fuel_transfer=transfer_occured})
    --pr("new stored fuel: %s", found_gen:binded_object().wrapper.stored_fuel)
end

-- Fuel Siphoning

function calc_stored_fuel()
    math.randomseed(time_continual())
    local rnd = clamp(round_idp(math.random() + math.random(1, 100), 2), 0, 100)
    if rnd <= 2.5 then
        return math.random(MAX_FUEL * 0.75, MAX_FUEL)
    elseif rnd <= 12.5 then
        return math.random(MAX_FUEL * 0.5, MAX_FUEL * 0.75)
    elseif rnd <= 20 then
        return math.random(MAX_FUEL * 0.25, MAX_FUEL * 0.5)
    elseif rnd <= 55 then
        return math.random(MAX_FUEL * 0.1, MAX_FUEL * 0.25)
    elseif rnd <= 80 then
        return math.random(1, MAX_FUEL * 0.1)
    elseif rnd <= 100 then
        return 0
    end
end

function init_fuel_barrel(obj)
    local id = obj:id()
    if not contains(fuel_barrels, id, true) then
        pr("init fuel barrel: %s", id)
        fuel_barrels[id] = {
            stored_fuel = calc_stored_fuel(),
            searched = false, -- Reset barrel after x amount of time past
            has_exploded = false,
        }
        if fuel_barrels[id]["stored_fuel"] > 0 then
            fuel_barrels[id]["reinit_time"] = time_global() + (math.random(24, 24*7) * 3600) * 1000
        end
        obj:set_tip_text(gts("st_siphon_fuel"))
        pr("Fuel barrel data: %s", print_table(fuel_barrels[id]))
    end
    return id
end

function reinit_fuel_barrel(obj)
    pr("reinit fuel barrel: %s", obj:id())
    remove_fuel_barrel(obj)
    return init_fuel_barrel(obj)
end

function remove_fuel_barrel(obj)
    if contains(fuel_barrels, obj:id(), true) then
        pr("removing %s from fuel barrels", obj:id())
        if not fuel_barrels[obj:id()]["has_exploded"] then
            fuel_barrels[obj:id()]["has_exploded"] = false
        end
        fuel_barrels[obj:id()] = nil
        obj:set_tip_text_default()
    end
end

function on_look_at_object()
    local obj = level.get_target_obj()
    if not obj then return end
    local sect = obj:section()
    if sect ~= "explosive_barrel" then return end
    init_fuel_barrel(obj)
end

function siphon_fuel_cond(obj)
    local p = obj:parent()
	if not (p and p:id() == AC_ID) then return end
    local sect = obj:section()
    local found_barrels = find_obj("explosive_barrel", db.actor:position(), SIPHON_RANGE)
    if is_empty(found_barrels) then return end
    local found_barrel = get_nearest(found_barrels)
    local dist = distance_between(db.actor, found_barrel)
    return sect == "hfg_siphon_kit" and  dist <= SIPHON_RANGE and contains(fuel_barrels, found_barrel:id(), true)
end

function siphon_fuel_menu(obj)
    return gts("st_item_use")
end

function siphon_fuel_func(obj)
    -- Barrel
    local found_barrels = find_obj("explosive_barrel", db.actor:position(), SIPHON_RANGE)
    local found_barrel = get_nearest(found_barrels)
    local id = found_barrel:id()
    local info = fuel_barrels[id]
    local tg = time_global()
    pr("Fuel barrel data: %s", print_table(info))
    if info["stored_fuel"] == 0  then
        fuel_barrels[id]["searched"] = true
        hide_hud_inventory()
        actor_menu.set_msg(1, gts("st_barrel_empty"), 3)
        return
    elseif info["searched"] and info["stored_fuel"] == 0 and tg >= info["reinit_time"] then
        pr("reinit time: %s, tg: %s", info["reinit_time"], tg)
        id = reinit_fuel_barrel(found_barrel)
    end

    -- Jerrycans
    local found_jerrycans = find_inv_item("jerrycan")
    if is_empty(found_jerrycans) then
        hide_hud_inventory()
        actor_menu.set_msg(1, gts("st_no_jerrycan"), 3)
        return
    end

    local total_empty_volume = 0
    for idx, obj in pairs(found_jerrycans) do
        local sect = obj:section()
        if string.find(sect, "empty") then
            total_empty_volume = total_empty_volume + 10
        else
            total_empty_volume = total_empty_volume + (10 - obj:get_remaining_uses())
        end
    end
    pr("total empty volume: %s", total_empty_volume)
    if total_empty_volume == 0 then 
        hide_hud_inventory()
        actor_menu.set_msg(1, gts("st_no_empty_jerrycan"), 3)
        return 
    end
    
    start_siphon_ui(id)
end

add_functor("siphon_fuel", siphon_fuel_cond, siphon_fuel_menu, nil, siphon_fuel_func)

function start_siphon_ui(id)
    pr("starting siphon ui")
    
    if not GUI then
        GUI = UISiphon()
    end

    if GUI and not GUI:IsShown() then
        hide_hud_inventory()
        GUI:Reset(id)
        GUI:ShowDialog(true)
        Register_UI("UISiphon")
    end
end

class "UISiphon" (CUIScriptWnd)
function UISiphon:__init() super()
    pr("init siphon ui")
    if not self.init then
        self:InitControls()
        self:InitCallbacks()
        self.init = true
    end
    pr("finished init")
end

function UISiphon:Reset(id)
    pr("reinit siphon ui")
	self.barrel_id = id
    self.stored_fuel = fuel_barrels[id]["stored_fuel"] or 0
    self.found_jerrycans = find_inv_item("jerrycan") or {}
    self.fuel_to_move = 0
    self:Setup()
end

function UISiphon:__finalize()
    pr("finalise siphon ui")
	GUI = nil
end


function UISiphon:InitControls()
    pr("init siphon controls")
	self:SetWndRect(Frect():set(0,0,1024,768))
    self:SetAutoDelete(true)

    self.xml = CScriptXmlInit()
    self.xml:ParseFile("ui_hfg.xml")

    self.frame = self.xml:InitFrame("frame", self)
    self.icon = self.xml:InitStatic("icon", self.frame)
    self.fuel_counter_jerrycan = self.xml:InitTextWnd("fuel_counter_jerrycan", self.frame)
    self.fuel_counter_barrel = self.xml:InitTextWnd("fuel_counter_barrel", self.frame)
    self.operation_text = self.xml:InitTextWnd("operation_text", self.frame)
    self.fuel_trackbar = self.xml:InitTrackBar("fuel_trackbar", self.frame)
    self.start_btn = self.xml:Init3tButton("start_btn", self.frame)
    --self.icon:SetWndSize(vector2():set(self.icon:GetWidth(), self.icon:GetWidth() / utils_xml.screen_ratio()))
    
    self:Register(self.fuel_trackbar, "fuel_trackbar")
    self:Register(self.start_btn, "start_btn")
    pr("fininshed controls")
end

function UISiphon:InitCallbacks()
    pr("init siphon callbacks")
    self:AddCallback("fuel_trackbar", ui_events.BUTTON_CLICKED, self.OnTrackBarMove, self)
    self:AddCallback("switch_btn", ui_events.BUTTON_CLICKED, self.OnClickSwitch, self)
    self:AddCallback("start_btn", ui_events.BUTTON_CLICKED, self.OnClickStart, self)
    pr("finished callbacks")
end

function UISiphon:Setup()
    pr("setup ui elements")
    self.fuel_counter_barrel:SetText(strformat("%sL", self.stored_fuel))
    local barrel_clrs = FUEL_TO_CLR["barrel"]
    local fuel_percent = nearest_val(get_keytable(barrel_clrs), round(self.stored_fuel / MAX_FUEL) * 100)
    self.fuel_counter_barrel:SetTextColor(GetARGB(unpack(barrel_clrs[fuel_percent])))

    local barrel_cnt_pos = self.fuel_counter_barrel:GetWndPos()
    local fuel_to_pos = FUEL_TO_POS["barrel"]
    local barrel_cnt_pos_y = fuel_to_pos[fuel_percent]
    self.fuel_counter_barrel:SetWndPos(vector2():set(barrel_cnt_pos.x, barrel_cnt_pos_y))

    self.operation_text:SetText(strformat(OP_TXT, self.fuel_counter_barrel:GetText()))

    self.fuel_trackbar:SetStep(1)
    self.fuel_trackbar:SetOptFBounds(0, self.stored_fuel)
    self.fuel_trackbar:SetFValue(self.stored_fuel)

    self.fuel_to_move = self.stored_fuel

    pr("Setup jerrycans")
    -- Sorting found jerrycans
    local t = {}
    self.total_volume = 0
    -- Putting empty jerrycans 1st
    for idx, obj in pairs(self.found_jerrycans) do
        local sect = obj:section()
        if sect == "hfg_jerrycan_diesel_empty" then
            t[#t + 1] = obj:id()
        end
    end

    -- Sort jerrycans from emptiest to fullest
    pr("sorting by fuel amount low - high")
    for idx, obj in pairs(self.found_jerrycans, function(t, a, b) return t[a]:get_remaining_uses() < t[b]:get_remaining_uses() end) do
        if not contains(t, obj:id()) then
            local uses = obj:get_remaining_uses()
            if uses < 10 then
                t[#t + 1] = obj
                self.total_volume = self.total_volume + obj:get_remaining_uses()
            else
                self.total_volume = self.total_volume + 10
            end
        end
    end
    
    pr("found jerrycans: %s", #self.found_jerrycans)
    local jerrycan = self.found_jerrycans[1]
    local is_jerrycan_empty = jerrycan:section() == "hfg_jerrycan_diesel_empty" and true or false
    self.fuel_counter_jerrycan:SetText(strformat("%sL", is_jerrycan_empty and 0 or jerrycan:get_remaining_uses()))
    
    -- Set Jerrycan Counter Colour
    local jerrycan_clrs = FUEL_TO_CLR["jerrycan"]
    local fuel_count = (is_jerrycan_empty and 0 or jerrycan:get_remaining_uses()) / 10 
    local fuel_percent = nearest_val(get_keytable(jerrycan_clrs), fuel_count * 100)
    self.fuel_counter_jerrycan:SetTextColor(GetARGB(unpack(jerrycan_clrs[fuel_percent])))
    
    -- Set Jerrycan Counter Pos on the gauge
    local jc_cnt_pos = self.fuel_counter_jerrycan:GetWndPos()
    local fuel_to_pos = FUEL_TO_POS["jerrycan"]
    local jc_cnt_pos_y = fuel_to_pos[fuel_percent]
    
    self.fuel_counter_jerrycan:SetWndPos(vector2():set(jc_cnt_pos.x, jc_cnt_pos_y))
    self.total_empty_volume = (10 * #self.found_jerrycans) - self.total_volume
    self.init = true

    pr("total fuel stored in jerry cans: %s", self.total_volume)
    pr("total space available: %s", self.total_empty_volume)
    pr("found jerrycans: %s", #self.found_jerrycans)
    pr("stored barrel fuel: %s", self.stored_fuel)
    pr("finished setup")
end

function UISiphon:OnTrackBarMove()
    pr("on trackbar move")
    self.fuel_to_move = self.fuel_trackbar:GetFValue()
    local operation_txt = strformat(OP_TXT, strformat("%sL", self.fuel_to_move))
    self.operation_text:SetText(operation_txt)
end

function UISiphon:OnClickStart()
    pr("on click start")
    if self.fuel_to_move == 0 then pr("no fuel to move") return end
    local fuel_to_move = self.fuel_to_move
    local add_new = {}
    local remove_full = {}
    for i=1, #self.found_jerrycans do
        -- take from barrel, put in jerrycan
        pr("stored fuel %s, empty vol: %s", self.stored_fuel, self.total_empty_volume)
        if self.stored_fuel == 0 or self.total_empty_volume == 0 then -- if no jerrycan can be filled or there is no fuel in the barrel
            pr("if all jerrycans are full or there is no fuel in the barrel")
            return 
        end

        local jc = self.found_jerrycans[i]
        
        local is_jerrycan_empty = string.find(jc:section(), "empty") and true or false
        pr("empty jerrycan: %s", is_jerrycan_empty)

        local space_left = 0
        pr("expected fuel to move: %s", self.fuel_to_move)
        -- Make sure theres room in the jerrycan for fuel, move to next if not
        space_left = is_jerrycan_empty and 10 or 10 - jc:get_remaining_uses()
        if space_left - self.fuel_to_move < 0 then
            for i=1, self.fuel_to_move do
                self.fuel_to_move = self.fuel_to_move - 1
                if space_left - self.fuel_to_move == 0 then
                    break
                end
            end
        end
        
        pr("space left: %s", space_left)
        pr("actual fuel to move: %s", self.fuel_to_move)
        if self.fuel_to_move <= 10 and self.fuel_to_move > 0 then
            local jerrycan_uses = is_jerrycan_empty and self.fuel_to_move or jc:get_remaining_uses() + self.fuel_to_move
            -- Update UI Elements with change fuel vars
            local percentage_removed = self.fuel_to_move/self.stored_fuel
            self.total_empty_volume = self.total_empty_volume - self.fuel_to_move
            self.stored_fuel = clamp(self.stored_fuel - self.fuel_to_move, 0, MAX_FUEL)
            self.fuel_trackbar:SetOptFBounds(0, self.stored_fuel)
            self.total_volume = self.total_volume + self.fuel_to_move
            self.fuel_trackbar:SetFValue(0, self.stored_fuel)
            self.fuel_to_move = self.stored_fuel

            local operation_txt = strformat(OP_TXT, strformat("%sL", self.stored_fuel))    
            self.operation_text:SetText(operation_txt)
            pr("setting op txt to: %s", operation_txt)

            if jerrycan_uses == 10 then
                pr("assign to be removed")
               remove_full[#remove_full + 1] = i
            end

            -- Jerrycan Text
            pr("updating counter text: jerrycan")
            self.fuel_counter_jerrycan:SetText(strformat("%sL", jerrycan_uses))
            local jerrycan_clrs = FUEL_TO_CLR["jerrycan"]
            local fuel_percent = nearest_val(get_keytable(jerrycan_clrs), (jerrycan_uses / 10) * 100)
            self.fuel_counter_jerrycan:SetTextColor(GetARGB(unpack(jerrycan_clrs[fuel_percent])))
            
            -- Jerrycan Pos
            pr("updating counter pos: jerrycan")
            local jc_cnt_pos = self.fuel_counter_jerrycan:GetWndPos()
            local fuel_to_pos = FUEL_TO_POS["jerrycan"]
            local jc_cnt_pos_y = fuel_to_pos[fuel_percent]
            self.fuel_counter_jerrycan:SetWndPos(vector2():set(jc_cnt_pos.x, jc_cnt_pos_y))

            -- Barrel Text
            pr("updating counter text: barrel")
            self.fuel_counter_barrel:SetText(strformat("%sL", self.stored_fuel))
            local barrel_clrs = FUEL_TO_CLR["barrel"]
            local barrel_fuel_percent = nearest_val(get_keytable(barrel_clrs), self.stored_fuel / MAX_FUEL)
            self.fuel_counter_barrel:SetTextColor(GetARGB(unpack(barrel_clrs[barrel_fuel_percent])))

            -- Barrel Pos
            pr("updating counter pos: barrel")
            local barrel_cnt_pos = self.fuel_counter_barrel:GetWndPos()
            local fuel_to_pos = FUEL_TO_POS["barrel"]
            local barrel_cnt_pos_y = fuel_to_pos[barrel_fuel_percent]
            self.fuel_counter_barrel:SetWndPos(vector2():set(barrel_cnt_pos.x, barrel_cnt_pos_y))
            
            pr("Stored Fuel: %s", self.stored_fuel)
            pr("Total Jerrycan Space Available: %s", self.total_empty_volume)
            pr("updating ui elements")
            
            -- Update Barrel Table
            pr("updating barrel table")
            fuel_barrels[self.barrel_id]["stored_fuel"] = self.stored_fuel
            fuel_barrels[self.barrel_id]["searched"] = true
            
            -- Update HF Data (uses) for jerrycans
            pr("updating hf data")
            local data = hf_obj_manager.get_data(jc:id())
            local update_id = jc:id()
            
            data["uses"] = jerrycan_uses
            pr("jerrycan_uses: %s", data["uses"])
            if is_jerrycan_empty then
            
                local new_sect = "hfg_jerrycan_diesel"
                local se_obj = alife_create_item(new_sect, db.actor, {uses=data["uses"]})               

                pr("releasing %s", jc:id())
                alife_release(alife_object(jc:id()))

                pr("Creating %s with id %s", new_sect, se_obj.id)
                replace_generator_item(data["tbl_id"], se_obj.id)
                data["tbl_id"] = se_obj.id
                data["item_section"] = new_sect
                update_id = se_obj.id
                local idx = #add_new + 1
                add_new[idx] = {}
                add_new[idx]["id"] = se_obj.id
                add_new[idx]["idx"] = i
            else
                jc:set_remaining_uses(data["uses"])
            end
            pr("update id: %s", update_id)
            hf_obj_manager.update_data(update_id, data)
        else
            self.fuel_to_move = fuel_to_move
        end

        if is_not_empty(add_new) then 
            local function search(_, obj)
                for i=1, #add_new do
                    if obj:id() == add_new[i]["id"] then
                        self.found_jerrycans[add_new[i]["idx"]] = obj
                    end
                end
            end
            itr_inv(db.actor, search)
        end

        if is_not_empty(remove_full) then
            for i=1, #remove_full do
                local idx = remove_full[i]
                self.found_jerrycans[idx] = nil
            end
        end
    end
end

function UISiphon:Close()
    pr("on close")
    if (self:IsShown()) then
		self:HideDialog()
	end
    self.init = false
    Unregister_UI("UISiphon")
    CloseAll_UI()
end

function UISiphon:OnKeyboard(dik, keyboard_action)
	local res = CUIScriptWnd.OnKeyboard(self,dik,keyboard_action)
	if (res == false) then
		local bind = dik_to_bind(dik)
		if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		
			if dik == DIK_keys.DIK_ESCAPE then
                pr("esc key pressed")
				self:Close()
			end

		end
	end

	return res
end









-- HFG Light furniture

function is_powerable_device(sect)
    local fuel_sect = ini_sys:r_string_ex(sect, "fuel_section")
    return contains(FUEL_SECTIONS, fuel_sect)
end

function get_powerable_devices(pos)
    pr("Getting powerable devices")
    local powerable_devices = {}
    local function search(obj)
        local sect = obj:section()
        if is_powerable_device(sect) then
            powerable_devices[obj:id()] = sect
        end
    end
    level.iterate_nearest(pos, SEARCH_RADIUS, search)
    --pr("Found powerable devices: %s", print_table(powerable_devices))
    return powerable_devices
end



-- Monkey Patches
base_toggle_light = ui_furniture_light.toggle_light
function ui_furniture_light.toggle_light(obj_id)
    pr("on toggle light")
    local se_obj = alife_object(obj_id)
    local found_gens = find_obj("placeable_disel_generator", se_obj.position, SEARCH_RADIUS)
    if is_not_empty(found_gens) then
        --pr("found genny: %s", print_table(found_gens))

        local found_gen = get_nearest(found_gens)
        local data = hf_obj_manager.get_data(found_gen:id())
        local powerable_devices = data["powerable_devices"]
        
        if is_not_empty(powerable_devices) then
            local power_state = data["power_state"]
            pr("power state: %s", power_state)
            if contains({"broken", "off"}, power_state) then
                local is_on = hf_obj_manager.get_data(obj_id)["is_on"]
                if is_on then
                    base_toggle_light(obj_id)
                    return
                end
                local item_sect = ini_sys:r_string_ex(se_obj:section_name(), "item_section")
                local light_name = gts(ini_sys:r_string_ex(item_sect, "inv_name"))
                actor_menu.set_msg(1, gts("st_requires_power", power_state, light_name), 3)
                return
            end
        end
    end
    pr("base toggle light")
    base_toggle_light(obj_id)
end

base_seperate = bind_item.func_separate
function bind_item.func_separate(obj)
    pr("on item seperate")
    local id = obj:id()
    local sect = obj:section()
    if not is_in_generator_item_tbl(id) then
        pr("base seperate: %s", id)
        base_seperate(obj)
        return
    end

	local uses = obj:get_remaining_uses()
	if uses and (uses > 1) then
		local se_obj = alife_create_item(sect, db.actor, {uses = 1})
		if se_obj then
            uses = uses - 1
			obj:set_remaining_uses(uses)
            --update_generator_item(id, {uses=uses})
            hf_obj_manager.update_data(id, {uses=uses})

            local info = {
                id = se_obj.id,
                sect = sect,
                uses = 1
            }
            init_generator_item(info)
        end
    end
end

base_drag_drop = bind_item.on_item_drag_dropped
function bind_item.on_item_drag_dropped(obj_1, obj_2, slot_from, slot_to)
    pr("on item drag dropped")
    if not (slot_from == EDDListType.iActorBag and slot_to == EDDListType.iActorBag) then
        return
    end

    local sec_1 = obj_1:section()
	local sec_2 = obj_2:section()

    if not is_generator_item(sec_1) then
        base_drag_drop(obj_1, obj_2, slot_from, slot_to)
        return
    end
	
	if not ((sec_1 == sec_2) and IsItem("multiuse",sec_1)) then
		return
	end

    local uses_1 = obj_1:get_remaining_uses()
	local uses_2 = obj_2:get_remaining_uses()
	local max_uses = obj_1:get_max_uses() 

	if not (uses_1 and uses_2 and max_uses) then
		return
	end

	local new_uses = uses_1 + uses_2
	if (new_uses > max_uses) then
		return
	end
	
	local id_1 = obj_1:id()
	local id_2 = obj_2:id()
	
    local se_obj = alife_object(id_1)
    if se_obj then
        pr("combining %s from %s uses to %s uses", sec_2, uses_2, new_uses)
        alife_release(se_obj)
        obj_2:set_remaining_uses(new_uses)
        remove_generator_item(id_1)
        hf_obj_manager.update_data(id_2, {uses=new_uses})
        itms_manager.play_item_sound(obj_2)
	end
end


-- Callbacks

function on_save(mdata)
    pr("on save")
    for id, datum in pairs(mdata["se_object"]) do
        if contains(datum, "hf_data", true) then
            pr("hf data: %s, %s", id, print_table(datum))
        end
    end
end

function on_item_take(obj)
    local id = obj:id()
    local sect = obj:section()
    if not is_generator_item(sect) or not is_placeable_item(sect) then return end
    if is_in_generator_item_tbl(id) then return pr("%s is in gen item tbl already", sect) end
    pr("on item take: %s", sect)
    init_generator_item({obj=obj})
end

function use_generator_item(obj)
    if add_fuel_cond(obj) then
        add_fuel_func(obj)
    end
end

actor_on_update = throttle(function()
    on_look_at_object()
  end, 1000)

function physic_object_on_hit(obj, amount, dir, who, bidx)
    pr("on physic ob hit: %s", obj:section())
end

function on_game_start()
    --RegisterScriptCallback("physic_object_on_hit_callback", physic_object_on_hit)
    RegisterScriptCallback("explosive_item_on_explode", remove_fuel_barrel)
    RegisterScriptCallback("explosive_item_on_explode", set_cond_on_explode)
    RegisterScriptCallback("actor_on_weapon_fired", set_cond_on_impact)
    RegisterScriptCallback("actor_on_item_take", on_item_take)
    RegisterScriptCallback("actor_on_item_use", use_generator_item)
    RegisterScriptCallback("actor_on_update", actor_on_update)
    --RegisterScriptCallback("save_state", on_save)
end