--[[
    Last Edited: 03/08/25
    Author: antglobes
    Purpose: Binding and Managing Diesel Generator Object
--]]

-- Library Imports
ag_utils.import_metatable(this, ag_game_objects)
ag_utils.import_metatable(this, ag_maths)
ag_utils.import_metatable(this, ag_npc)
ag_utils.import_metatable(this, ag_position)
ag_utils.import_metatable(this, ag_strings)
ag_utils.import_metatable(this, ag_tables)

gts = get_translation

-- External Imports
AOE = demonized_aoe.AOE
geo_ray = demonized_geometry_ray.geometry_ray

-- Utils
get_hf_item_name = hfg_utils.get_hf_item_name
bone_to_part_name = hfg_utils.bone_to_part_name
get_bone_pos = hfg_utils.get_bone_pos
get_config = hfg_utils.get_config
get_parts_tbl = hfg_utils.get_parts_tbl
get_powerable_devices = hfg_utils.get_powerable_devices
cond_to_state = hfg_utils.cond_to_state
bones_by_distance = hfg_utils.bones_by_distance
disassemble_power_source = hfg_utils.disassemble_power_source
update_power_source_cond = hfg_utils.update_power_source_cond
SWAP_POWER_STATE = hfg_utils.SWAP_POWER_STATE

-- Constants
MIN_COND = 0.01
LOG_HEADER = "[HFG|Bind Disel Gen]"
MS_HOUR = 3.6 * math.pow(10, 6) -- Hours to Millisecond
HOUR_SEC = 3.6 * math.pow(10, 3)
GEN_ITEM = "disel_generator_item"
PART_REPAIR_COND = 0.25

-- MCM Variables
SEARCH_RADIUS = 50
BROKEN_COND = 0.1
MAX_FUEL = 60
MAX_POWER_OUTPUT = 5000

-- Locals
local dbg_pr = nil

-- DEBUGGING
function setup_log(level, header, enabled)
    if not dbg_pr then
        dbg_pr = ag_logging.new({
            level=level,
            header=header,
            enabled=enabled
        })
    else
        dbg_pr:SetLevel(level)
        dbg_pr:Enable(enabled)
    end
end

function dbg(level, fmt, ...)
    if not dbg_pr then
        setup_log(get_config("debug_level"), LOG_HEADER, get_config("enable_debug"))    
    end
    dbg_pr:Log(level, fmt, ...)
end


function toggle_power(obj_id)
    dbg("debug", "Toggle Power")
    local data = hf_obj_manager.get_data(obj_id)
    --dbg("dev", "Genny data: %s\n", data)
    local se_obj = alife_object(obj_id)
    local in_progress = data["anim_in_progress"]
    if in_progress then dbg("info", "anim in progress, cant switch power state") return end

    local ps_sect = se_obj:section_name()
    local power_state = data["power_state"]
    if power_state then
        local gen_name = get_hf_item_name(ps_sect)
        if power_state == "broken" then 
            actor_menu.set_msg(1, gts("st_generator_broken", gen_name), 3)
            return 
        end

        local has_fuel = contains(data, "stored_fuel", true) and data["stored_fuel"] > 0 or false
        if not has_fuel then
            dbg("info", "no fuel")
            actor_menu.set_msg(1, gts("st_no_fuel"), 3)
            return
        end

        local obj = get_unknown_object({id=obj_id}, "game")
        if obj then
            dbg("info", "Switching interact tip to %s", power_state)
            obj:set_tip_text(gts("st_power_state_" .. power_state, gen_name))
        end

        dbg("debug", "Attempting to switch power from %s to %s", power_state, SWAP_POWER_STATE[power_state])
        hf_obj_manager.update_data(obj_id, {power_state=SWAP_POWER_STATE[power_state], last_power_state=power_state, anim_due=true})
        return true
    end
    dbg("info", "genny left in current state")
end

-- Diesel Generator Binder

function init(obj, was_blueprint)
    local id = obj:id()
    local sect = obj:section()
    dbg("dev", "attempt binding %s", sect)
    if contains(hfg_blueprint.placed_blueprints, id, true) then
        dbg("dev", "cannot bind %s, as is a blueprint ", sect)
        return
    end
    
    hfg_obj_persistance.init(id, sect, {tbl_id=id})
    dbg("dev", "binding %s", sect)
    obj:bind_object(placeable_disel_generator_wrapper(obj).binder)
end

class "placeable_disel_generator_wrapper" (bind_hf_base.hf_binder_wrapper)
function placeable_disel_generator_wrapper:__init(obj) super(obj)
    dbg("dev", "Initalising genny")

    local data = hf_obj_manager.get_data(self.object:id())
   
    -- Object Fields
    self.section = self.object:section()
    self.item_section = ini_sys:r_string_ex(self.section, "item_section")
    self.condition = (contains(data, "condition", true) and data["condition"]) or 1
    self.placeable_type = ini_sys:r_string_ex(self.item_section, "placeable_type")
    self.parts = contains(data, "parts", true) and data["parts"] or self:InitParts()
    
    -- Object State
    self.power_state = self.condition > BROKEN_COND and (data["power_state"] or "off") or "broken"
    self.object:set_tip_text(gts("st_power_state_" .. SWAP_POWER_STATE[self.power_state], get_hf_item_name(self.section)))
    self.current_motion = "idle"
    self.powerable_device_tmr = 0

    -- Animation State
    self.anim_due = data["anim_due"] or false
    self.anim_in_progress = data["anim_in_progress"] or false
    self.anim_stage = data["anim_stage"] or 1
    self.anim_state = data["anim_state"] or ""
    self.anim_power_state = data["anim_power_state"] or ""

    -- Animation snd
    self.snd = data["snd"] or {}
    --self.snd["last_played"] = contains(data["snd"], "last_played", true) and data["snd"]["last_played"] or nil

    -- Animation Time
    self.anim_tmr = data["anim_tmr"] or 0

    -- Animation tbl
    self.anim_tbl = data["anim_tbl"] or {
        on = {
            [1] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start",              },
            [2] = {anim="work",     duration=6, snd="ambient\\pripyat\\pri_b306_generator_start"},
            [3] = {anim="work_2x",  duration=0, snd="ambient\\pripyat\\pri_b306_generator_work"}
        },
        off = {
            [1] = {anim="work",     duration=6, snd="ambient\\pripyat\\pri_b306_generator_work"},
            [2] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start"},
            [3] = {anim="idle",     duration=0, snd="device\\bridge\\motor_stop"}
        },
        broken = {
            [1] = {anim="work_2x",  duration=5, snd="weapons\\explo\\dynamite_boom"},
            [2] = {anim="work_0.5", duration=2, snd="device\\bridge\\motor_start"},
            [3] = {anim="idle",     duration=0, snd="device\\bridge\\motor_stop"}
        }
    }

    -- Particles

    self.last_cond_state = data["last_cond_state"] or ""
    self.curr_fx = data["curr_fx"] or {}
    self.fx_tbl = { -- rpt = repeat, slp = sleep
        broken = {
            [1] = {part="explosions\\expl_car_smoke_big",                duration={active=13,  pause=2, rpt=1},          bone_name="exhaust", count=0, loop=false, active=false, tmr=0},
            [2] = {part="explosions\\explosion_dynamite",                duration={active=1.2, pause=3.8, rpt=1},        bone_name="body",    count=0, loop=false, active=false, tmr=0},
        },
        low = {
            [1] = {part="explosions\\expl_car_smoke_small",              duration={active=13, pause=2},                  bone_name="r_rotor", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="explosions\\campfire_hot_no_fire",              duration={active=1, pause=0.5, rpt=5, slp=60},  bone_name="r_rotor", count=0, loop=true,  active=false, tmr=0},
            [3] = {part="vehiclefx\\niva_damagedexhaust_01",             duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        },
        med = {
            [1] = {part="vehiclefx\\generic_exhaust_01",                 duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="vehiclefx\\exhaust_kamaz",                      duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        },
        high = {
            [1] = {part="vehiclefx\\exhaust_1",                          duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
            [2] = {part="vehiclefx\\niva_damagedexhaust_01",             duration={active=1, pause=0.5, rpt=5},          bone_name="exhaust", count=0, loop=false, active=false, tmr=0},
            [3] = {part="industrial_particles\\exhaust_workshop_1",      duration={active=15},                           bone_name="exhaust", count=0, loop=true,  active=false, tmr=0},
        }
    }

    -- Powerable Devices
    self.power_off_devices = data["power_off_devices"] or true
    self.powerable_devices = data["powerable_devices"] or {} -- get_powerable_devices(self.object:position())
    self.max_power_output = ini_sys:r_float_ex(self.section, "max_power_output", MAX_POWER_OUTPUT)
    self.power_output = data["power_output"] or self.max_power_output
    self.update_pd_tmr = data["update_pd_tmr"] or 0
    self.last_power_output = data["last_power_output"] or self.power_output
    self.last_power_state = data["last_power_state"] or "off"

    -- Fuel
    self.stored_fuel = data["stored_fuel"] or 0
    self.max_fuel = data["max_fuel"] or MAX_FUEL
    self.fuel_transfer = data["fuel_transfer"] or false
    self.time_til_empty = data["time_til_empty"] or 0
    self.fuel_tmr = data["fuel_tmr"] or 0
    self.drain_rate = {
        [0.5]  = 1.2,
        [0.75] = 1.48,
        [1]    = 2
    }
    self.time_last = get_time_elapsed()
    dbg("dev", "saving data")
    self:save_data()
    dbg("all", "finished init")
end

function placeable_disel_generator_wrapper:update(delta)
    bind_hf_base.hf_binder_wrapper.update(self, delta)

    self.tg = time_global()
    self:load_data()

    -- dbg("dev", "getting cond state")
    local condition = self.condition
    local cond_state = cond_to_state(round_idp(condition * 100, 2))
    
    -- dbg("dev", "processing power output")
    -- Process Power Output
    
    
    self.ProcessPowerState(cond_state)
    self:ProcessParticles(cond_state)
    self:ProcessAnims()
    self:ProcessPowerableDevices()
    self:ProcessFuel()
end

function placeable_disel_generator_wrapper:ProcessPowerState(cond_state)
    -- On Power State Switch
    if self.last_power_state ~= self.power_state then
        dbg("info", "processing power state")
        dbg("info", "Changing from %s to %s", self.last_power_state, self.power_state)
        self.object:set_tip_text(gts("st_power_state_" .. SWAP_POWER_STATE[self.power_state], get_hf_item_name(self.section)))
        if self.power_state == "broken" and cond_state == "broken" then
            if not self.anim_in_progress and self.current_motion ~= "idle" then
                self.anim_due = true
            end
        end

        if self.power_state == "on" then
            self.power_output = self.last_power_output
        elseif contains({"off", "broken", self.power_state}) then
            self.last_power_output = self.power_output
            self.power_output = 0
        end
        self.last_power_state = self.power_state
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:ProcessParticles(cond_state)
    if self.item_section == GEN_ITEM then
        if self.power_state == "on" or (self.power_state == "broken" and self.current_motion ~= "idle") then
            -- If Condition Has Changed enough for a particle update
            if cond_state ~= self.last_cond_state then
                dbg("dev", "cond state: %s", cond_state)
                -- If there are particles currently playing, stop them, update curr fx
                if is_not_empty(self.curr_fx) and contains(self.curr_fx, self.last_cond_state) then
                    local fx = self.curr_fx[self.last_cond_state]
                    for idx, details in pairs(fx) do
                        if details["active"] and contains(details, "id", true) then
                            thial_particles.remove(details["id"])
                        end
                    end
                end
                
                self.curr_fx[cond_state] = self.fx_tbl[cond_state]
                self.last_cond_state = cond_state
            end

            for idx, details in pairs(self.curr_fx[self.last_cond_state]) do
                if self.tg > details["tmr"] then
                    if not details["active"] then                    
                        self.curr_fx[self.last_cond_state][idx].tmr = self.tg + (details["duration"]["active"] * 1000)
                        self.curr_fx[self.last_cond_state][idx].active = true
                        --pr("exhaust pos: %s", vec_to_str(self.exhaust_pos))
                        self.curr_fx[self.last_cond_state][idx].id = thial_particles.add(details["part"], get_bone_pos(self.object, details["bone_name"]), (details["duration"]["active"]*1000))
                        if details["bone_name"] == "exhaust" then
                            dbg("dev", "setiting part dir to be exhaust dir")
                            local part_obj = thial_particles.get(self.curr_fx[self.last_cond_state][idx].id)
                            local exhaust_pos = get_bone_pos(self.object, "exhaust")
                            local link_pos =  get_bone_pos(self.object, "body")
                            --pr("dir: %s", vec_to_str(norm_dir))
                            local norm_dir = get_direction(link_pos, exhaust_pos)
                            part_obj:set_direction(norm_dir)
                        end
                        dbg("info", "Playing particle: %s for %s", details["part"], details["duration"]["active"])
                    elseif details["active"] then
                        local remove_particle = false

                        if details["duration"]["pause"] then
                            self.curr_fx[self.last_cond_state][idx].tmr = self.tg + (details["duration"]["pause"] * 1000)
                            self.curr_fx[self.last_cond_state][idx].active = false
                            dbg("dev", "pausing %s for %s", details["part"], details["duration"]["pause"])
                            if details["duration"]["rpt"] then
                                self.curr_fx[self.last_cond_state][idx].count = self.curr_fx[self.last_cond_state][idx]["count"] + 1
                                dbg("dev", "advancing repeat: %s", self.curr_fx[self.last_cond_state][idx].count)
                                if self.curr_fx[self.last_cond_state][idx]["count"] >= details["duration"]["rpt"] then
                                    if not details["loop"] then
                                        dbg("dev", "particle finished cycle")
                                        self.curr_fx[self.last_cond_state][idx].tmr = 0
                                        self.curr_fx[self.last_cond_state][idx].count = 0
                                        --self.curr_fx[self.last_cond_state][idx].active = false
                                        self.particle_id = self.curr_fx[self.last_cond_state][idx]["id"]
                                        self.curr_fx[self.last_cond_state][idx] = nil
                                        remove_particle = true
                                        if self.last_cond_state == "broken" and self.current_motion ~= "idle" then
                                            self:Explode()
                                            self.anim_due = true
                                            self.power_state = self.last_cond_state
                                        end
                                    elseif details["loop"] and details["duration"]["slp"] then
                                        dbg("dev", "particle %s reached end of loop putting to sleep for %s", details["part"], details["duration"]["slp"])
                                        self.curr_fx[self.last_cond_state][idx].tmr = self.tg + details["duration"]["slp"]
                                    end
                                end
                            end                    
                        else
                            dbg("info", "reseting particle")
                            self.curr_fx[self.last_cond_state][idx].tmr = 0
                            self.curr_fx[self.last_cond_state][idx].active = false
                        end

                        if remove_particle then
                            dbg("info", "removing particle")
                            thial_particles.remove(self.particle_id)
                        end
                    
                    end
                end
                self:save_data()
            end

        elseif self.power_state == "off" then        
            self:CleanupParticles()
        end
    end
end

function placeable_disel_generator_wrapper:ProcessAnims()
    if self.item_section == GEN_ITEM then
        if self.anim_due then
            if not self.anim_in_progress then
                dbg("dev", "Setting Anim Control Vars")
                self.anim_in_progress = true
                self.anim_power_state = self.power_state
                self.anim_start_time = self.tg
                self:CleanupParticles()
                dbg("dev", "anim power state: %s", self.anim_power_state)
            end

            -- Prevent Toggle Power being constantly pressed from interrupting an animation
            if self.anim_in_progress and self.anim_power_state ~= self.power_state then
                dbg("info", "Attempted to change power state during anim, using anim set power state")
                self.power_state = self.anim_power_state
                --pr("power state: %s", self.power_state)
            end

            -- End Process if Animation Time not reached
            if self.tg < self.anim_tmr then
                return
            end
            dbg("dev", "Anim Time Reached")
            -- If Anim Gets stuck and/or has exceed it's animation time whilst a cond changes reset it/ move to next stage
            if self.tg > self.anim_tmr and self.tg - self.anim_start_time > self.anim_tmr then
                dbg("info", "Anim Runtime Exceed, Advancing Stage")
                self.anim_tmr = 0
                self.anim_stage = self.anim_stage + 1
            end

            -- Stop Animation and Reset Controllers
            dbg("all", "Anim stage %s, total stages %s", self.anim_stage, #self.anim_tbl[self.power_state])
            if self.anim_stage > #self.anim_tbl[self.power_state] then
                dbg("dev", "stopping anim")
                self.anim_due = false
                self.anim_in_progress = false
                self.anim_tmr = 0
                self.anim_stage = 1
                self.power_off_devices = contains({"off", "broken"}, self.power_state)
                self:save_data()
                return
            end

            dbg("dev", "Starting Anim Stage %s at %s", self.anim_stage, self.tg)
            -- Play Animation for given duration and advance/save animation
            local details = self.anim_tbl[self.power_state][self.anim_stage]        
            local snd_props = sound_object.s3d + sound_object.looped
            local last_stage = #self.anim_tbl[self.power_state]
            if self.anim_stage < last_stage or self.anim_stage == last_stage and contains({"off", "broken"}, self.power_state) then
                --pr("Not looping snd")
                snd_props = sound_object.s3d
            end

            if self.snd["last_played"] ~= nil  then
                ag_sounds.remove(self.snd["last_played"])
                dbg("info", "Stopping last played snd. Played for %s", self.tg - self.anim_tmr)
            end
            if details["snd"] then
                self.snd["last_played"] = ag_sounds.add(self.object, details["snd"], self.object:position(),  0.7, snd_props)
                dbg("info", "playing sound %s", details["snd"])
            end
            dbg("dev", "Starting to play %s at %s", details["anim"], self.tg)

            self.object:play_cycle(details["anim"])
            --self:UpdateAnimData(details["anim"])
            self.current_motion = details["anim"]
            dbg("dev", "setting current motion to %s", details["anim"])
            self.anim_tmr = self.tg + (details["duration"] * 1000)
            dbg("dev", "setting next anim time to %s", self.anim_tmr)
            self.anim_stage = self.anim_stage + 1
            dbg("dev", "advancing anim stage to: %s", self.anim_stage)
            self:save_data()
            dbg("all", "saved data")
        end
    end
end

function placeable_disel_generator_wrapper:ProcessPowerableDevices()
    if not contains({"broken", "off"}, self.power_state) then
        if self.tg > self.update_pd_tmr then
            local found_powerable_devices = get_powerable_devices(self.object:position())
            if is_not_empty(found_powerable_devices) then
                for id, obj in pairs(found_powerable_devices) do                    
                    if not contains(self.powerable_devices, id, true) then
                        dbg("dev", "adding new powerable devices")
                        dbg("dev", "current power output: %s", self.power_output)
                        local info = self:InitPDInfo(obj)
                        self.powerable_devices[id] = info
                        local wrapper = bind_hf_base.get_wrapper(id)
                        if wrapper then
                            dbg("dev", "init %s powered status", id)
                            wrapper.power_source_id=self.object:id()
                        end
                        dbg("dev", "id: %s, watts needed %s, new power output: %s", id, info.watts_needed, power_output)
                    end
                end
                self:save_data()          
            end
            self.update_pd_tmr = self.tg + 1000
        end

        if self.tg > self.powerable_device_tmr then
            -- Check from smallest to biggest consumer if it can be powered with current power output
            local next_update = 300
            dbg("dev", "current power output: %s", self.power_output)
            local power_remaining = self.power_output
            for id, info in pairs(self.powerable_devices) do
                power_remaining = power_remaining - info.watts_needed
                if power_remaining >= 0 and not info.watts_satisfied then 
                    dbg("dev", "watts satisifed for %s", info.name)
                    info.watts_satisfied = true
                end
                --self:save_data()
            end

            -- Update fuel if powered otherwise switch off
            for id, info in pairs(self.powerable_devices) do
                local data = hf_obj_manager.get_data(id)
                if data and info.watts_satisfied then
                    if 
                        contains(data, "fuel", true) 
                        and not contains(data, "infinite_fuel", true)
                        and data["fuel"] <= 0.1 
                    then
                        dbg("info", "updating fuel")
                        hf_obj_manager.update_data(id, {fuel=1})
                    end
                elseif data and not info.watts_satisfied then
                   if data["is_on"] then
                        dbg("dev", "Watts not satisfied for %s", info.name)
                        hf_obj_manager.update_data(id, {is_on=false})
                        self.power_output = self.power_output + info.watts_needed
                        local msg = gts("st_watts_unsatisfied", get_hf_item_name(self.section), info.name)
                        actor_menu.set_msg(1, msg, 3)
                    end
                end
            end                
            
            self.powerable_device_tmr = self.tg + next_update
            self:save_data()
        end
        self:save_data()
    end    

    if self.power_off_devices then
        dbg("debug", "turning off devices")
        for id, info in pairs(self.powerable_devices) do
            hf_obj_manager.update_data(id, {is_on=false})
            info.watts_satisfied = false
        end
        self.power_off_devices = false
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:ProcessFuel()
    if self.stored_fuel <= 0 or self.time_til_empty <= 0 then
        if self.item_section == GEN_ITEM and self.power_state == "on" and not self.anim_in_progress then
            dbg("debug", "no fuel switching off")
            self.power_state = "off"
            self.anim_due = true
            self.stored_fuel = 0
        end
    end

    local percent_full = self.stored_fuel / self.max_fuel
    local drain_rate = get_keytable(self.drain_rate )
    local fuel_load = nearest_val(drain_rate, percent_full)

    if self.fuel_transfer then
        dbg("info", "resesting time til empty")
        self.time_til_empty = (self.stored_fuel / self.drain_rate[fuel_load]) * HOUR_SEC
        dbg("all", "percent full: %s, drain_rate: %s, fuel_load: %s", percent_full, drain_rate, fuel_load)
        dbg("dev", "time til empty: %s", self.time_til_empty)
        dbg("dev", "stored fuel: %s", self.stored_fuel)
        self.fuel_tmr = self.tg
        self.fuel_transfer = false
    end

    if self.power_state == "broken" then
        self.time_til_empty = 0
    end

    if self.tg > self.fuel_tmr and self.power_state == "on" and self.time_til_empty > 0 then
        local drain_rate_sec = (self.drain_rate[fuel_load] / HOUR_SEC)
        self.stored_fuel = self.stored_fuel - drain_rate_sec 

        local time_curr = get_time_elapsed()
        local time_diff = time_curr - self.time_last
        local time_frac = (time_diff/1)
        local tte = self.time_til_empty - time_frac
        self.time_til_empty = tte >= 0 and tte or 0
        dbg("all", "stored fuel: %s", self.stored_fuel)
        dbg("all", "using %s fuel per ms", drain_rate_sec)
        dbg("all", "current time:%s, time diff:%s, time frac:%s", time_curr, time_diff, time_frac)
        self.fuel_tmr = time_global() + 1000
        self.time_last = time_curr
    end
    self:save_data()
end

function placeable_disel_generator_wrapper:InitParts()
    local parts = {}
    for bone_id, bone_name in pairs(self.object:list_bones()) do
        local part_name = bone_to_part_name(bone_name, self.placeable_type)
        if not contains(parts, part_name, true) then
            parts[part_name] = {}
            parts[part_name].name = part_name
            parts[part_name].condition = 1
            parts[part_name].bone_name = bone_name
            parts[part_name].bone_id = bone_id
            parts[part_name].components = get_parts_tbl(part_name)
            local name = part_name:gsub("hfg_prt_", "")
            local dam_multi = hfg_utils.part_damage_multi[self.placeable_type][name]
            dbg("dev", "name: %s, dam multi: %s", name, dam_multi)
            parts[part_name].dam_multi =  dam_multi + round_idp(math.random(0.01, 0.5), 2)
            -- dbg("dev", "adding %s to parts", part_name)
        end
    end
    -- dbg("dev", "parts table: %s", parts)
    self.parts = parts
    self:save_data()
end

function placeable_disel_generator_wrapper:InitPDInfo(device)
    local info = {}
    local typ = get_obj_type(device)
    local id = get_unknown_id(device, typ)
    local sect = get_unknown_sect(device, typ)
    info.name = sect
    info.watts_needed = ini_sys:r_string_ex(sect, "fuel_duration") or 300
    info.watts_satisfied = false
    return info
end

function placeable_disel_generator_wrapper:Explode()
    local aoe_args = {
        position = self.object:position(),
        aoe_sound = "anomaly\\fireball_idle",
        aoe_hit_sound = "anomaly\\fire2",
        lifetime = 3,
        can_panic_npc = true,
        draftsman_id = self.object:id()
    }
    aoe_args.damage = aoe_args.lifetime * 2
    aoe_args.explosion_damage = aoe_args.damage + (aoe_args.damage / 4)
    aoe_args.damage_period = (aoe_args.lifetime / 2) * 1000

    local found_generators = find_obj(self.section, aoe_args.position, 10)
    aoe_args.radius = 3
    if is_not_empty(found_generators) then
        local nearest_gen = get_nearest(found_generators, aoe_args.position)
        aoe_args.radius = clamp(nearest_gen:position():distance_to(aoe_args.position), 3, 10)
        for _, obj in pairs(found_generators) do
            local data = hf_obj_manager.get_data(obj:id())
            if data.condition > BROKEN_COND then
                update_power_source_cond(obj, data.condition, data.power_state, aoe_args.damage)
            end
        end
    end

    self.stored_fuel = self.stored_fuel - (self.stored_fuel * round_idp(math.random(0.8, 1), 2))
    AOE(aoe_args)
    dbg("dev", "aoe_args: %s", aoe_args)
end

function placeable_disel_generator_wrapper:CleanupParticles()
    if is_not_empty(self.curr_fx) and contains(self.curr_fx, self.last_cond_state) then
        dbg("dev", "power off removing particles")
        local fx = self.curr_fx[self.last_cond_state]
        for idx, details in pairs(fx) do
            if details["active"] and contains(details, "id", true) then
                thial_particles.remove(details["id"])
            end
        end
        self:save_data()
    end
end

function placeable_disel_generator_wrapper:GetInfo()
    return {
        condition         = self.condition,
        stored_fuel       = self.stored_fuel,
        time_til_empty    = self.time_til_empty,
        power_output      = self.power_output,
    }
end

function placeable_disel_generator_wrapper:pickup()
    dbg("info", "on pickup")
    self:load_data()
    local gen_id = self.object:id()
    local data = hf_obj_manager.get_data(gen_id)
    -- Create Item with condition
    if self.condition > BROKEN_COND then
        dbg("all", "binder cond: %s", self.condition)
        local se_obj = alife_create(self.item_section, db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, false)
        local item_data = utils_stpk.get_item_data(se_obj)
        item_data.condition = self.condition
        utils_stpk.set_item_data(item_data, se_obj)
        alife():register(se_obj)

        -- Replace gen id
        -- replace_generator(data["tbl_id"], se_obj.id)
        local old = {id=data["tbl_id"], sect=self.section}
        local new = {id=se_obj.id, sect=self.item_section}
        hfg_obj_persistance.replace(old, new)

        data["tbl_id"] = se_obj.id
        hf_obj_manager.update_data(se_obj.id, data)
        hf_obj_manager.cleanup_data(gen_id)
        alife_release(self.object)
    else
        hfg_obj_persistance.remove(gen_id, self.item_section)
        hf_obj_manager.cleanup_data(gen_id)
        disassemble_power_source(self.item_section, data["parts"], self.object)
    end

    -- Clean up HF-related data
    return true
end

function placeable_disel_generator_wrapper:net_spawn()
    dbg("dev", "on net spawn")
    self:load_data()
    if self.snd and contains(self.snd, "last_played", true) then
        dbg("dev", "reseting sound")
        ag_sounds.reinit(self.snd["last_played"], self.object)
    end
end

function placeable_disel_generator_wrapper:net_destroy()
    dbg("dev", "on net destroy")
    self:save_data()
    if self.snd and contains(self.snd, "last_played", true) then
        dbg("dev", "removing sound")
        local id = self.snd["last_played"]
        ag_sounds.stop(id)
    end
    empty_table(self.powerable_devices)
    self:CleanupParticles()
end

function placeable_disel_generator_wrapper:save_data()
    dbg("all", "save data")
    local data = {
        power_state          = self.power_state,
        anim_due             = self.anim_due,
        anim_in_progress     = self.anim_in_progress,
        anim_stage           = self.anim_stage,
        anim_state           = self.anim_state,
        anim_tmr             = self.anim_tmr,
        anim_tbl             = self.anim_tbl,
        anim_power_state     = self.anim_power_state,
        snd                  = self.snd,
        last_cond_state      = self.last_cond_state,
        curr_fx              = self.curr_fx,
        fx_tbl               = self.fx_tbl,
        condition            = self.condition,
        powerable_devices    = self.powerable_devices,
        power_off_devices    = self.power_off_devices,
        current_motion       = self.current_motion,
        anim_start_time      = self.anim_start_time,
        last_power_state     = self.last_power_state,
        powerable_device_tmr = self.powerable_device_tmr,
        power_output         = self.power_output,
        stored_fuel          = self.stored_fuel,
        max_fuel             = self.max_fuel,
        fuel_transfer        = self.fuel_transfer,
        time_til_empty       = self.time_til_empty,
        drain_rate           = self.drain_rate,
        update_pd_tmr        = self.update_pd_tmr,
        parts                = self.parts,
        fuel_tmr             = self.fuel_tmr,
        item_section         = self.item_section,
        max_power_output     = self.max_power_output,
        placeable_type       = self.placeable_type,
        time_last            = self.time_last,
        last_power_output    = self.last_power_output,
    }
    -- dbg("dev", "saving hf data with: %s", data)
    local curr_data = hf_obj_manager.get_data(self.object:id())
    if curr_data and contains(curr_data, "tbl_id", true) then
        -- update_generator(curr_data["tbl_id"], data)
        -- dbg("dev", "updating persistance data")
        hfg_obj_persistance.update(curr_data["tbl_id"], self.section, data)
    end
    -- dbg("dev", "updating hf data")
    hf_obj_manager.update_data(self.object:id(), data)
    -- dbg("dev", "completed save")
end

function placeable_disel_generator_wrapper:load_data()
    dbg("all", "on load")
    local data = hf_obj_manager.get_data(self.object:id())
    self.power_state          = data["power_state"]
    self.anim_due             = data["anim_due"]
    self.anim_in_progress     = data["anim_in_progress"]
    self.anim_stage           = data["anim_stage"]
    self.anim_state           = data["anim_state"]
    self.anim_tmr             = data["anim_tmr"]
    self.anim_tbl             = data["anim_tbl"]
    self.anim_power_state     = data["anim_power_state"]
    self.snd                  = data["snd"]
    self.last_cond_state      = data["last_cond_state"]
    self.curr_fx              = data["curr_fx"]
    self.fx_tbl               = data["fx_tbl"]
    self.condition            = data["condition"]
    self.powerable_devices    = data["powerable_devices"]
    self.power_off_devices    = data["power_off_devices"]
    self.current_motion       = data["current_motion"]
    self.anim_start_time      = data["anim_start_time"]
    self.last_power_state     = data["last_power_state"]
    self.powerable_device_tmr = data["powerable_device_tmr"]
    self.power_output         = data["power_output"]
    self.stored_fuel          = data["stored_fuel"]
    self.max_fuel             = data["max_fuel"]
    self.fuel_transfer        = data["fuel_transfer"]
    self.time_til_empty       = data["time_til_empty"]
    self.drain_rate           = data["drain_rate"]
    self.update_pd_tmr        = data["update_pd_tmr"]
    self.parts                = data["parts"]
    self.fuel_tmr             = data["fuel_tmr"]
    self.item_section         = data["item_section"]
    self.max_power_output     = data["max_power_output"]
    self.placeable_type       = data["placeable_type"]
    self.time_last            = data["time_last"]
    self.last_power_output    = data["last_power_output"]

    -- dbg("dev", "Genny data: %s\n", data)
end

function get_time_elapsed()
   return game.get_game_time():diffSec(level.get_start_time()) 
end


function set_cond_on_explode(obj)
    local explo_sect = obj:section()
    dbg("info", "set_cond_on_explode: %s", explo_sect)
    local found_objs = {}
    local function search(obj)
        local sect = obj:section()
        if is_not_empty({string.find(sect, "disel_generator")}) then
            dbg("dev", "found genny: %s", sect)
            found_objs[#found_objs + 1] = obj
        end
    end

    local radius = ini_sys:r_float_ex(explo_sect, "blast_r")
    level.iterate_nearest(obj:position(), radius, search)

    if is_empty(found_objs) then return end
    for i=1, #found_objs do
        local gen = table.remove(found_objs, i)
        if gen then
            local data = hf_obj_manager.get_data(gen:id())
            if data["anim_in_progress"] then return end
            local power_state = data["power_state"]
            local cond = data["condition"] or 1
            local hit_damage = ini_sys:r_float_ex(explo_sect, "blast_impulse") / 100
            -- shoot a ray from obj to genny
            -- if hit any material get material
            -- check to see how much the material would absorb the damage
            -- apply to cond
            update_power_source_cond(gen, cond, power_state, hit_damage)
        end
    end   
end

    

-- Callbacks
function on_option_change(options)
    setup_log(options["debug_level"], LOG_HEADER, options["enable_debug"])
    dbg("debug", "Received options")
    SEARCH_RADIUS = options["search_radius"]
    BROKEN_COND = options["broken_cond"]
    MAX_FUEL = options["max_fuel"]
    MAX_POWER_OUTPUT = options["max_power_output"]
end

function on_game_start()
    -- RegisterScriptCallback("explosive_item_on_explode", set_cond_on_explode)
    RegisterScriptCallback("hfg_on_option_change", on_option_change)
    -- RegisterScriptCallback("actor_on_update", actor_on_update)
end

--[[
local consumers = {
    {name="industrial_light_a", watts_needed=400},
    {name="industrial_light_b", watts_needed=500},
    {name="industrial_light_c", watts_needed=750},
    {name="tv"                , watts_needed=1200},
    {name="domestic_light"    , watts_needed=450},
}
local power_produced = 500
local total_power_consumed = 0
-- Imagine consumers, have been registered
for _, info in pairs(consumers) do
    total_power_consumed = total_power_consumed + info.watts_needed
end

math.randomseed(tonumber(os.time()))
local battery = {stored=800, max=1000}
local amount_to_drain = 0
local power_deficit = 0
if total_power_consumed > power_produced then
    table.sort(consumers, function(a, b) return a.watts_needed < b.watts_needed end)
    print("power produced", power_produced)
    print("total power needed", total_power_consumed, "\n")
    print("stored power in battery", battery.stored)
    local power_consumed = power_produced
    for idx, info in pairs(consumers) do
        power_consumed = power_consumed - info.watts_needed
        local power_met = power_consumed >= 0
        print("watts_needed", info.watts_needed)
        print("power remaining", power_consumed)
        print("power met for?:", info.name, power_met)
        print("current power stored in battery", battery.stored)
        if not power_met and battery.stored > 0 then
            local remaining_power = battery.stored - info.watts_needed
            local power_left = remaining_power > 0 and remaining_power or 0
            print("remaining battery power", remaining_power)
            print("power_left", power_left)
            if power_left > 0 then
               print("reclacing battery power")
               local watts_needed = info.watts_needed
               for i=1, watts_needed do
                    watts_needed = watts_needed - 1
                    if battery.stored - watts_needed == 0 then                       
                       power_left = (info.watts_needed - watts_needed)
                       remaining_power = battery.stored - power_left
                        print("power_left", power_left)
                        print("re calc remaining battery power", remaining_power)
                        print("\n")
                        break
                    end
               end 
            else
                print("\n")
            end
           
            amount_to_drain = amount_to_drain + power_left
            battery.stored = remaining_power
            power_consumed = power_consumed + info.watts_needed
        else
            print("\n")
        end
    end
    power_deficit = total_power_consumed - amount_to_drain
    print("\n")
    print("total amount to drain from battery:", amount_to_drain)
    print("total power deficit", power_deficit)
end
=======================================
if total_watts_consumed > self.max_power_output then
-- Check for nearby batteries
                -- Get available stored power
                -- Calculate amount to drain
                local batteries_nearby = false
                if batteries_nearby then
                    local battery = {power_stored=0, max_power=0}
                    local amount_to_drain = 0

                    local power_remaining = self.max_power_output
                    for id, info in spairs(self.powerable_devices, function(t, a, b) return t[a].watts_needed < t[b].watts_needed end) do
                        if battery.power_stored == 0 and is_not_empty(batteries_nearby) then
                            local obj = table.remove(batteries_nearby, 1)
                            local id = obj:id()
                            local battery_data = hf_obj_manager.get_data(id)
                            battery.power_stored = battery_data["power_stored"]
                            battery.max_power = battery_data["max_power_stored"]
                        end
                       
                        power_remaining = power_remaining - info.watts_needed
                        if power_remaining >= 0 and battery.power_stored > 0 then
                            local remaining_stored_power = battery.power_stored - info.watts_needed
                            if remaining_stored_power > 0 then
                                local watts_needed = info.watts_needed
                                for i=1, watts_needed do
                                    power_remaining = battery.stored - (info.watts_needed - watts_needed)
                                    break

                                end
                            end
                            amount_to_drain = amount_to_drain + power_left
                            battery.stored = remaining_power
                            power_consumed = power_consumed + info.watts_needed
                        end
                    end

                end
]]