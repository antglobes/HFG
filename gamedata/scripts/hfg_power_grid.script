-- Library Imports
ag_utils.import_metatable(this, ag_tables)
ag_utils.import_metatable(this, ag_game_objects)
ag_utils.import_metatable(this, ag_position)

-- Script Imports
throttle = ag_utils.throttle

-- Utils
get_config = hfg_utils.get_config
is_power_source = hfg_utils.is_power_source
is_power_consumer = hfg_utils.is_power_consumer
is_power_obj = hfg_utils.is_power_obj
get_power_type = hfg_utils.get_power_type
get_power_data = hfg_utils.get_power_data
within_range = hfg_utils.within_range
get_power_consumers = hfg_utils.get_power_consumers
get_power_sources = hfg_utils.get_power_sources
get_power_storage = hfg_utils.get_power_storage

-- Constants
LOG_HEADER = "[HFG|Power Grid]"
SEARCH_RADIUS = get_config("power_source_search_radius")

-- Globals
grids = {}

-- Locals
local dbg_pr = nil

-- DEBUGGING
function setup_log(level, header, enabled)
    if not dbg_pr then
        dbg_pr = ag_logging.new({
            level=level,
            header=header,
            enabled=enabled
        })
    else
        dbg_pr:SetLevel(level)
        dbg_pr:Enable(enabled)
    end
end

function dbg(level, fmt, ...)
    if not dbg_pr then
        setup_log(get_config("debug_level"), LOG_HEADER, get_config("enable_debug"))    
    end
    dbg_pr:Log(level, fmt, ...)
end

function in_grid(args)
    if is_empty(grids) then return false end
    local typ = args.typ
    local level_name = args.level_name

    if typ == "level" then
        return contains(grids, level_name, true)

    elseif typ == "grid" then
        local grid_id = args.grid_id
        return contains(grids, level_name, true) 
            and contains(grids[level_name], grid_id, true)

    elseif typ == "power" then
        local grid_id = args.grid_id
        local power_typ = args.power_typ
        local power_obj_id = args.power_obj_id
        if
            contains(grids, level_name, true)
            and contains(grids[level_name], grid_id, true)
            and contains(grids[level_name][grid_id], power_typ, true)
        then
            local power_objs = grids[level_name][grid_id][power_typ]
            return contains(power_objs, power_obj_id, true)
        end
    end

    return false
end

function init_grid(obj)
    local obj_id = obj:id()
    local obj_sect = obj:section()
    if not is_power_obj(obj_sect) then return end
    local level_name = level.name()
    --if not in_grid({typ="level", level_name=level_name}) then return end
    dbg("dev", "init grid")
    -- Collect all grids on current level
    local level_grids = {}
    if is_not_empty(grids) then
        for grid_id, grid_data in pairs(grids) do
            if grid_data["lvl_name"] == level_name then
                level_grids[grid_id] = grid_data
            end
        end
    end

    local num_level_grids = size_table(level_grids)
    local obj_pos = obj:position()
    local power_typ = get_power_type(obj_sect)
    local power_data = get_power_data(obj, power_typ)
    dbg("dev", "number of grids on level: %s", num_level_grids)
    dbg("dev", "id: %s, sect: %s, power typ: %s", obj_id, obj_sect, power_typ)
    
            
    if is_not_empty(level_grids) then
        dbg("dev", "existing grid for level: %s", level_grids)
        -- Add to closest existing grid
        
        -- Collect distances for each grid id
        dbg("dev", "Getting closest grid id")
        local closest_grid_id = num_level_grids
        local closest_grid_dist
        for grid_id, grid_data in pairs(level_grids) do
            for id, data in pairs(grid_data[power_typ]) do
                local dist = obj_pos:distance_to(data["pos"])
                dbg("dev", "dist: %s", dist)
                if not closest_grid_dist or dist < closest_grid_dist then
                    closest_grid_dist = dist
                    closest_grid_id = grid_id
                end
            end
        end
        
        dbg("dev", "closest grid dist: %s, closest grid id: %s", closest_grid_dist, closest_grid_id)
        
        if closest_grid_dist and closest_grid_dist < SEARCH_RADIUS then        
            -- Get nearest grid
            local closest_grid = level_grids[closest_grid_id]
            dbg("dev", "closest grid data: %s", closest_grid)
            closest_grid[power_typ] = contains(closest_grid, power_typ, true) and closest_grid[power_typ] or {}
            closest_grid[power_typ][obj_id] = power_data
            
            dbg("dev", "Updating power grid table: %s", closest_grid)
            grids[closest_grid_id] = closest_grid
            hf_obj_manager.update_data(obj_id, {grid_id=closest_grid_id})
            return
        end
    end
    
    dbg("dev", "Adding new power grid")
    local grid_id = num_level_grids + 1
    grids[grid_id] = {
        lvl_name = level_name,
        grid_id = grid_id,
        [power_typ] = {
            [obj_id] = power_data
        }
    }
    hf_obj_manager.update_data(obj_id, {grid_id=grid_id})
    dbg("dev", "For grid id: %s, new grid data: %s", grid_id, grids[grid_id])
end

function delay_init_grid(obj_id)
    local se_obj = alife_object(obj_id)
    local sect = se_obj:section_name()
    if not se_obj  then return end
    if not is_power_obj(sect) then return end
    dbg("info", "on delay init grid: %s|:%s", sect, obj_id)
    CreateTimeEvent("hf_power_grid"..se_obj.id, "delay_init_grid"..se_obj.id, 0.4, function()
        local obj = get_unknown_object({id=se_obj.id}, "game")
        if not obj then return false end
        init_grid(obj)
        return true
    end)
end

update_grids = throttle(
    function()
        if not grids or is_empty(grids) or not level.present() then
            return
        end

        local level_name = level.name()
        for grid_id, grid_data in pairs(grids) do
            if grid_data["lvl_name"] == level_name then

                local power_data = contains(grid_data, "power_data", true) and grid_data["power_data"] or {}
                local total_power_output = contains(power_data, "total_power_output") and power_data["total_power_output"] or 0
                if contains(grid, "power_sources", true) and is_not_empty(grid["power_sources"]) then
                    for id, data in pairs(grid_data["power_sources"]) do
                        local hf_data = hf_obj_manager.get_data(id)

                        -- Disable power output if broken or off
                        data["power_state"] = hf_data["power_state"]
                        if contains({"off", "broken"}, data["power_state"]) then
                            data["power_output"] = 0
                        end

                        -- Update nearby power consumers
                        data["consumers"] = contains(data, "consumers", true) and data["consumers"] or {}
                        local found_consumers = get_power_consumers(data["pos"])
                        if is_not_empty(found_consumers) then
                            for pc_id, consumer in pairs(found_consumers) do
                                if not contains(data["consumers"], pc_id) then
                                    data["consumers"][#data["consumers"] + 1] = pc_id
                                end
                            end
                        end

                        -- Check that power source can satisfy it's consumers
                        local num_satisfied = 0
                        local power_remaining = data["power_output"]
                        if is_not_empty(data["consumers"]) and contains(grid_data, "power_consumers", true) then
                            for _, pc_id in pairs(data["consumers"]) do
                                local pc_data = grid_data["power_consumers"][pc_id]
                                local power_satisfied = pc_data["power_satisfied"]
                                if not power_satisfied then
                                    local power_needed = pc_data["power_needed"]
                                    power_remaining = power_remaining - power_needed
                                    if power_remaining >= 0 then
                                        power_satisfied = true
                                        grid_data["power_consumers"][pc_id].power_satisfied = power_satisfied
                                        grid_data["power_consumers"][pc_id].power_satisfied_typ = 0
                                    else
                                        grid_data["power_consumers"][pc_id].power_satisfied_typ = 0
                                    end
                                end
                                num_satisfied = power_satisfied and num_satisfied + 1 or num_satisfied
                            end
                            data["power_remaining"] = power_remaining
                            data["all_consumers_satisfied"] = is_not_empty(data["consumers"]) and size_table(data["consumers"]) == num_satisfied or 0
                            total_power_output = total_power_output + data["power_output"]
                        end
                    end
                    -- Total power output based on sum of power output from all power sources
                    power_data["total_power_output"] = total_power_output
                end

                
                local total_power_demand = contains(power_data, "total_power_demand") and power_data["total_power_demand"] or 0
                if contains(grid_data, "power_consumers", true) and is_not_empty(grid_data["power_consumers"]) then
                    for id, data in pairs(grid_data["power_consumers"]) do
                        local hf_data = hf_obj_manager.get_data(id)
                        
                        data["power_state"] = hf_data["power_state"]
                        local power_satisfied = data["power_satisfied"]
                        local power_needed = data["power_needed"]
                        
                        if not power_satisfied then                        
                            if data["power_state"] == "on" then                            
                                data["power_state"] = "off"
                            end

                            -- Check if extent of power not satisfied being partial:0 or full:1 or init:-1
                            local power_satisfied_typ = data["power_satisfied_typ"]
                            if power_satisfied_typ == 0 then
                                if is_not_empty(grid_data["power_sources"]) then
                                    for ps_id, ps_data in pairs(grid_data["power_sources"]) do
                                        if not contains(data["sources"], ps_id) and ps_data["power_remaining"] - power_needed >= 0 then
                                            data["sources"][#data["sources"] + 1] = ps_id
                                            data["power_satisfied"] = true
                                            data["power_satisfied_typ"] = -1
                                        end
                                    end
                                end

                                if not data["power_satisfied"] then
                                    data["power_satisfied_typ"] = 1
                                end

                            elseif power_satisfied_typ == 1 then
                                if is_not_empty(grid_data["power_storage"]) then
                                    for pst_id, pst_data in pairs(grid_data["power_storage"]) do
                                        if pst_data["power_stored"] > 0 and pst_data["power_stored"] - power_needed > 0 then
                                            data["power_satisfied"] = true
                                            data["power_satisfied_typ"] = -1
                                            data["sources"][#data["sources"] + 1] = pst_id
                                        end
                                    end
                                end
                            end

                        elseif power_satisfied then
                            if contains({"off", "broken", data["power_state"]}) then
                                data["power_state"] = "on"
                            
                            elseif data["power_state"] == "on" then
                                if 
                                    contains(hf_data, "fuel", true) 
                                    and not contains(hf_data, "infinite_fuel", true)
                                    and hf_data["fuel"] <= 0.1 
                                then
                                    hf_obj_manager.update_data(id, {fuel=1})
                                end
                                -- Update consumer here
                            end
                        end                   

                        total_power_demand = total_power_demand + data["power_needed"]
                    end
                    -- total power demand based on sum of power consumed from all power consumers
                    power_data["total_power_demand"] = total_power_demand
                end
                -- total power stored based on sum of power stored from all power storage
                local total_power_stored = contains(power_data, "total_power_stored") and power_data["total_power_stored"] or 0
                if contains(grid, "power_storage", true) and is_not_empty(grid_data["power_storage"]) then
                    for id, data in pairs(grid_data["power_storage"]) do
                        total_power_stored = total_power_stored + data["power_stored"]
                    end
                end

                grid_data["power_data"] = power_data
            end
        end
        -- dbg("dev", "grid data for %s: %s", level_name, grids[level_name])
    end, 1000)

-- Callbacks

function on_option_change(options)
    setup_log(options["debug_level"], LOG_HEADER, options["enable_debug"])
    dbg("debug", "Received options")
    SEARCH_RADIUS = options["power_source_search_radius"]
end

function on_game_start()
    RegisterScriptCallback("hfg_on_option_change", on_option_change)
    RegisterScriptCallback("hf_on_furniture_place", delay_init_grid)
    RegisterScriptCallback("actor_on_update", update_grids)
end


--[[
grids[level_name][grid_id][power_typ][data][power_obj_id]
grids = {
    [level_name] = {
        [1] = {
            power_sources = {
                [1907] = {
                    id = 1907,
                    sect = "placeable_disel_generator",
                    power_output = 5000,
                    power_state = 1,
                    pos = [12, 4, 583],
                    consumers = {2579, 2199, 2948},
                }
            },
            power_storage = {
                [1] = {
                    id = 2359
                    sect = "placeable_makeshift_battery",
                    pos = [23, 4, 323],
                    power_stored = 500,
                    sources = {1907},
                }
            }
            power_consumers = {
                [1] = {
                    id = 2579,
                    sect = "placeable_light5",
                    pos = [212, 4, 73],
                    power_state = 1,
                    power_needed = 300,
                    sources = {1907},
                },
                [2] = {
                    id = 2948,
                    sect = "placeable_tv_box",
                    pos = [112, 4, 233],
                    power_state = 1,
                    power_needed = 600,
                    sources = {1907},
                },
                [3] = {
                    id = 2199,
                    sect = "placeable_light2",
                    pos = [132, 4, 263],
                    power_state = 1,
                    power_needed = 300,
                    sources = {1907},
                }
            },
            power_data = {
                total_power_output = 5000,
                total_power_demand = 1200,
                total_power_stored = 500,
            }
        }
    }
}

second revision
grids = {
    lvl_name = "l05_bar",
    grid_id = 1,
    power_sources = {
        [1907] = {
            id = 1907,
            sect = "placeable_disel_generator",
            power_output = 5000,
            power_state = 1,
            pos = [12, 4, 583],
            consumers = {2579, 2199, 2948},
        }
    },
    power_consumers = {
        [2579] = {
            id = 2579,
            sect = "placeable_light5",
            pos = [212, 4, 73],
            power_state = 1,
            power_needed = 300,
            sources = {1907},
        },
        [2948] = {
            id = 2948,
            sect = "placeable_tv_box",
            pos = [112, 4, 233],
            power_state = 1,
            power_needed = 600,
            sources = {1907},
        },
        [2199] = {
            id = 2199,
            sect = "placeable_light2",
            pos = [132, 4, 263],
            power_state = 1,
            power_needed = 300,
            sources = {1907},
        }
    },
    power_data = {
        total_power_output = 5000,
        total_power_demand = 1200,
        total_power_stored = 500,
    }
}


]]

